   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.unselect_rows,"ax",@progbits
  13               	unselect_rows:
  14               	.LFB18:
  15               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "print.h"
  26:matrix.c      **** #include "debug.h"
  27:matrix.c      **** #include "util.h"
  28:matrix.c      **** #include "matrix.h"
  29:matrix.c      **** 
  30:matrix.c      **** 
  31:matrix.c      **** #ifndef DEBOUNCE
  32:matrix.c      **** #define DEBOUNCE	0
  33:matrix.c      **** #endif
  34:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  35:matrix.c      **** 
  36:matrix.c      **** /* matrix state(1:on, 0:off) */
  37:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  38:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  39:matrix.c      **** 
  40:matrix.c      **** static matrix_row_t read_cols(void);
  41:matrix.c      **** static void init_cols(void);
  42:matrix.c      **** static void unselect_rows(void);
  43:matrix.c      **** static void select_row(uint8_t row);
  44:matrix.c      **** 
  45:matrix.c      **** 
  46:matrix.c      **** inline
  47:matrix.c      **** uint8_t matrix_rows(void)
  48:matrix.c      **** {
  49:matrix.c      ****     return MATRIX_ROWS;
  50:matrix.c      **** }
  51:matrix.c      **** 
  52:matrix.c      **** inline
  53:matrix.c      **** uint8_t matrix_cols(void)
  54:matrix.c      **** {
  55:matrix.c      ****     return MATRIX_COLS;
  56:matrix.c      **** }
  57:matrix.c      **** 
  58:matrix.c      **** void matrix_init(void)
  59:matrix.c      **** {
  60:matrix.c      ****     // JTAG disable for PORT F. write JTD bit twice within four cycles.
  61:matrix.c      ****     MCUCR |= (1<<JTD);
  62:matrix.c      ****     MCUCR |= (1<<JTD);
  63:matrix.c      **** 
  64:matrix.c      ****     // initialize row and col
  65:matrix.c      ****     unselect_rows();
  66:matrix.c      ****     init_cols();
  67:matrix.c      **** 
  68:matrix.c      ****     // initialize matrix state: all keys off
  69:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  70:matrix.c      ****         matrix[i] = 0;
  71:matrix.c      ****         matrix_debouncing[i] = 0;
  72:matrix.c      ****     }
  73:matrix.c      **** }
  74:matrix.c      **** 
  75:matrix.c      **** uint8_t matrix_scan(void)
  76:matrix.c      **** {
  77:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  78:matrix.c      ****         select_row(i);
  79:matrix.c      ****         _delay_us(30);  // without this wait read unstable value.
  80:matrix.c      ****         matrix_row_t cols = read_cols();
  81:matrix.c      ****         if (matrix_debouncing[i] != cols) {
  82:matrix.c      ****             matrix_debouncing[i] = cols;
  83:matrix.c      ****             if (debouncing) {
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
  85:matrix.c      ****             }
  86:matrix.c      ****             debouncing = DEBOUNCE;
  87:matrix.c      ****         }
  88:matrix.c      ****         unselect_rows();
  89:matrix.c      ****     }
  90:matrix.c      **** 
  91:matrix.c      ****     if (debouncing) {
  92:matrix.c      ****         if (--debouncing) {
  93:matrix.c      ****             _delay_ms(1);
  94:matrix.c      ****         } else {
  95:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  96:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
  97:matrix.c      ****             }
  98:matrix.c      ****         }
  99:matrix.c      ****     }
 100:matrix.c      **** 
 101:matrix.c      ****     return 1;
 102:matrix.c      **** }
 103:matrix.c      **** 
 104:matrix.c      **** bool matrix_is_modified(void)
 105:matrix.c      **** {
 106:matrix.c      ****     if (debouncing) return false;
 107:matrix.c      ****     return true;
 108:matrix.c      **** }
 109:matrix.c      **** 
 110:matrix.c      **** inline
 111:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 112:matrix.c      **** {
 113:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 114:matrix.c      **** }
 115:matrix.c      **** 
 116:matrix.c      **** inline
 117:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 118:matrix.c      **** {
 119:matrix.c      ****     return matrix[row];
 120:matrix.c      **** }
 121:matrix.c      **** 
 122:matrix.c      **** void matrix_print(void)
 123:matrix.c      **** {
 124:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 125:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 126:matrix.c      ****         phex(row); print(": ");
 127:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 128:matrix.c      ****         print("\n");
 129:matrix.c      ****     }
 130:matrix.c      **** }
 131:matrix.c      **** 
 132:matrix.c      **** uint8_t matrix_key_count(void)
 133:matrix.c      **** {
 134:matrix.c      ****     uint8_t count = 0;
 135:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 136:matrix.c      ****         count += bitpop16(matrix[i]);
 137:matrix.c      ****     }
 138:matrix.c      ****     return count;
 139:matrix.c      **** }
 140:matrix.c      **** 
 141:matrix.c      **** 
 142:matrix.c      ****  /* Column pin configuration
 143:matrix.c      ****  * col:  0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f
 144:matrix.c      ****  * pin: B3  B2  B1  B0  E3  F1  F2  F3  F4  F5  F6  F7  A0  A1  A2  A3
 145:matrix.c      ****  */
 146:matrix.c      ****  static void  init_cols(void)
 147:matrix.c      **** {
 148:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 149:matrix.c      ****     DDRB  &= ~(1<<3 | 1<<2 | 1<<1 | 1<<0);
 150:matrix.c      ****     PORTB |=  (1<<3 | 1<<2 | 1<<1 | 1<<0);
 151:matrix.c      ****     DDRE  &= ~(1<<3);
 152:matrix.c      ****     PORTE |=  (1<<3);
 153:matrix.c      ****     DDRF  &= ~(1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 154:matrix.c      ****     PORTF |=  (1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 155:matrix.c      ****     DDRA  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3);
 156:matrix.c      ****     PORTA |=  (1<<0 | 1<<1 | 1<<2 | 1<<3);
 157:matrix.c      **** }
 158:matrix.c      **** 
 159:matrix.c      **** static matrix_row_t read_cols(void)
 160:matrix.c      **** {
 161:matrix.c      ****     return (PINB&(1<<3) ? 0 : (1<<0)) |
 162:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<1)) |
 163:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<2)) |
 164:matrix.c      ****            (PINB&(1<<0) ? 0 : (1<<3)) |
 165:matrix.c      ****            (PINE&(1<<3) ? 0 : (1<<4)) |
 166:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<<5)) |
 167:matrix.c      ****            (PINF&(1<<2) ? 0 : (1<<6)) |
 168:matrix.c      ****            (PINF&(1<<3) ? 0 : (1<<7)) |
 169:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<8)) |
 170:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<9)) |
 171:matrix.c      ****            (PINF&(1<<6) ? 0 : (1<<10)) |
 172:matrix.c      ****            (PINF&(1<<7) ? 0 : (1<<11)) |
 173:matrix.c      ****            (PINA&(1<<0) ? 0 : (1<<12)) |
 174:matrix.c      ****            (PINA&(1<<1) ? 0 : (1<<13)) |
 175:matrix.c      ****            (PINA&(1<<2) ? 0 : (1<<14)) |
 176:matrix.c      ****            (PINA&(1<<3) ? 0 : (1<<15));
 177:matrix.c      **** }
 178:matrix.c      **** 
 179:matrix.c      **** /* row pin configuration
 180:matrix.c      ****  * row: 0   1   2   3   4   5   6   7   
 181:matrix.c      ****  * pin: C4  C5  C6  C7  A7  A6  A5  A4
 182:matrix.c      ****  * pin: A4  A5  A6  A7  C7  C6  C5  C4     
 183:matrix.c      ****  */
 184:matrix.c      **** 
 185:matrix.c      **** static void unselect_rows(void)
 186:matrix.c      **** {
  16               		.loc 1 186 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 187:matrix.c      ****     // Hi-Z(DDR:0, PORT:0) to unselect
 188:matrix.c      ****     DDRA  &= ~0b11110000;
  22               		.loc 1 188 0
  23 0000 81B1      		in r24,0x1
  24 0002 8F70      		andi r24,lo8(15)
  25 0004 81B9      		out 0x1,r24
 189:matrix.c      ****     PORTA &= ~0b11110000;
  26               		.loc 1 189 0
  27 0006 82B1      		in r24,0x2
  28 0008 8F70      		andi r24,lo8(15)
  29 000a 82B9      		out 0x2,r24
 190:matrix.c      ****     DDRC  &= ~0b11110000;
  30               		.loc 1 190 0
  31 000c 87B1      		in r24,0x7
  32 000e 8F70      		andi r24,lo8(15)
  33 0010 87B9      		out 0x7,r24
 191:matrix.c      ****     PORTC &= ~0b11110000;
  34               		.loc 1 191 0
  35 0012 88B1      		in r24,0x8
  36 0014 8F70      		andi r24,lo8(15)
  37 0016 88B9      		out 0x8,r24
  38 0018 0895      		ret
  39               		.cfi_endproc
  40               	.LFE18:
  42               		.section	.text.matrix_rows,"ax",@progbits
  43               	.global	matrix_rows
  45               	matrix_rows:
  46               	.LFB7:
  48:matrix.c      **** {
  47               		.loc 1 48 0
  48               		.cfi_startproc
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
  50:matrix.c      **** }
  53               		.loc 1 50 0
  54 0000 88E0      		ldi r24,lo8(8)
  55 0002 0895      		ret
  56               		.cfi_endproc
  57               	.LFE7:
  59               		.section	.text.matrix_cols,"ax",@progbits
  60               	.global	matrix_cols
  62               	matrix_cols:
  63               	.LFB8:
  54:matrix.c      **** {
  64               		.loc 1 54 0
  65               		.cfi_startproc
  66               	/* prologue: function */
  67               	/* frame size = 0 */
  68               	/* stack size = 0 */
  69               	.L__stack_usage = 0
  56:matrix.c      **** }
  70               		.loc 1 56 0
  71 0000 80E1      		ldi r24,lo8(16)
  72 0002 0895      		ret
  73               		.cfi_endproc
  74               	.LFE8:
  76               		.section	.text.matrix_init,"ax",@progbits
  77               	.global	matrix_init
  79               	matrix_init:
  80               	.LFB9:
  59:matrix.c      **** {
  81               		.loc 1 59 0
  82               		.cfi_startproc
  83               	/* prologue: function */
  84               	/* frame size = 0 */
  85               	/* stack size = 0 */
  86               	.L__stack_usage = 0
  61:matrix.c      ****     MCUCR |= (1<<JTD);
  87               		.loc 1 61 0
  88 0000 85B7      		in r24,0x35
  89 0002 8068      		ori r24,lo8(-128)
  90 0004 85BF      		out 0x35,r24
  62:matrix.c      ****     MCUCR |= (1<<JTD);
  91               		.loc 1 62 0
  92 0006 85B7      		in r24,0x35
  93 0008 8068      		ori r24,lo8(-128)
  94 000a 85BF      		out 0x35,r24
  65:matrix.c      ****     unselect_rows();
  95               		.loc 1 65 0
  96 000c 0E94 0000 		call unselect_rows
  97               	.LVL0:
  98               	.LBB23:
  99               	.LBB24:
 149:matrix.c      ****     DDRB  &= ~(1<<3 | 1<<2 | 1<<1 | 1<<0);
 100               		.loc 1 149 0
 101 0010 84B1      		in r24,0x4
 102 0012 807F      		andi r24,lo8(-16)
 103 0014 84B9      		out 0x4,r24
 150:matrix.c      ****     PORTB |=  (1<<3 | 1<<2 | 1<<1 | 1<<0);
 104               		.loc 1 150 0
 105 0016 85B1      		in r24,0x5
 106 0018 8F60      		ori r24,lo8(15)
 107 001a 85B9      		out 0x5,r24
 151:matrix.c      ****     DDRE  &= ~(1<<3);
 108               		.loc 1 151 0
 109 001c 6B98      		cbi 0xd,3
 152:matrix.c      ****     PORTE |=  (1<<3);
 110               		.loc 1 152 0
 111 001e 739A      		sbi 0xe,3
 153:matrix.c      ****     DDRF  &= ~(1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 112               		.loc 1 153 0
 113 0020 80B3      		in r24,0x10
 114 0022 8170      		andi r24,lo8(1)
 115 0024 80BB      		out 0x10,r24
 154:matrix.c      ****     PORTF |=  (1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 116               		.loc 1 154 0
 117 0026 81B3      		in r24,0x11
 118 0028 8E6F      		ori r24,lo8(-2)
 119 002a 81BB      		out 0x11,r24
 155:matrix.c      ****     DDRA  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3);
 120               		.loc 1 155 0
 121 002c 81B1      		in r24,0x1
 122 002e 807F      		andi r24,lo8(-16)
 123 0030 81B9      		out 0x1,r24
 156:matrix.c      ****     PORTA |=  (1<<0 | 1<<1 | 1<<2 | 1<<3);
 124               		.loc 1 156 0
 125 0032 82B1      		in r24,0x2
 126 0034 8F60      		ori r24,lo8(15)
 127 0036 82B9      		out 0x2,r24
 128               	.LVL1:
 129 0038 E0E0      		ldi r30,lo8(matrix)
 130 003a F0E0      		ldi r31,hi8(matrix)
 131 003c A0E0      		ldi r26,lo8(matrix_debouncing)
 132 003e B0E0      		ldi r27,hi8(matrix_debouncing)
 133               	.LVL2:
 134               	.L5:
 135               	.LBE24:
 136               	.LBE23:
 137               	.LBB25:
  70:matrix.c      ****         matrix[i] = 0;
 138               		.loc 1 70 0 discriminator 2
 139 0040 1192      		st Z+,__zero_reg__
 140 0042 1192      		st Z+,__zero_reg__
  71:matrix.c      ****         matrix_debouncing[i] = 0;
 141               		.loc 1 71 0 discriminator 2
 142 0044 1D92      		st X+,__zero_reg__
 143 0046 1D92      		st X+,__zero_reg__
  69:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 144               		.loc 1 69 0 discriminator 2
 145 0048 80E0      		ldi r24,hi8(matrix+16)
 146 004a E030      		cpi r30,lo8(matrix+16)
 147 004c F807      		cpc r31,r24
 148 004e 01F4      		brne .L5
 149               	/* epilogue start */
 150               	.LBE25:
  73:matrix.c      **** }
 151               		.loc 1 73 0
 152 0050 0895      		ret
 153               		.cfi_endproc
 154               	.LFE9:
 156               		.section	.text.matrix_scan,"ax",@progbits
 157               	.global	matrix_scan
 159               	matrix_scan:
 160               	.LFB10:
  76:matrix.c      **** {
 161               		.loc 1 76 0
 162               		.cfi_startproc
 163 0000 AF92      		push r10
 164               	.LCFI0:
 165               		.cfi_def_cfa_offset 3
 166               		.cfi_offset 10, -2
 167 0002 BF92      		push r11
 168               	.LCFI1:
 169               		.cfi_def_cfa_offset 4
 170               		.cfi_offset 11, -3
 171 0004 CF92      		push r12
 172               	.LCFI2:
 173               		.cfi_def_cfa_offset 5
 174               		.cfi_offset 12, -4
 175 0006 DF92      		push r13
 176               	.LCFI3:
 177               		.cfi_def_cfa_offset 6
 178               		.cfi_offset 13, -5
 179 0008 EF92      		push r14
 180               	.LCFI4:
 181               		.cfi_def_cfa_offset 7
 182               		.cfi_offset 14, -6
 183 000a FF92      		push r15
 184               	.LCFI5:
 185               		.cfi_def_cfa_offset 8
 186               		.cfi_offset 15, -7
 187 000c CF93      		push r28
 188               	.LCFI6:
 189               		.cfi_def_cfa_offset 9
 190               		.cfi_offset 28, -8
 191 000e DF93      		push r29
 192               	.LCFI7:
 193               		.cfi_def_cfa_offset 10
 194               		.cfi_offset 29, -9
 195               	/* prologue: function */
 196               	/* frame size = 0 */
 197               	/* stack size = 8 */
 198               	.L__stack_usage = 8
 199               	.LVL3:
 200 0010 60E0      		ldi r22,lo8(matrix_debouncing)
 201 0012 C62E      		mov r12,r22
 202 0014 60E0      		ldi r22,hi8(matrix_debouncing)
 203 0016 D62E      		mov r13,r22
  76:matrix.c      **** {
 204               		.loc 1 76 0
 205 0018 7601      		movw r14,r12
  77:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 206               		.loc 1 77 0
 207 001a D0E0      		ldi r29,0
 208               	.LBB40:
 209               	.LBB41:
 210               	.LBB42:
 211               	.LBB43:
 161:matrix.c      ****     return (PINB&(1<<3) ? 0 : (1<<0)) |
 212               		.loc 1 161 0
 213 001c C1E0      		ldi r28,lo8(1)
 214               	.LVL4:
 215               	.L39:
 216               	.LBE43:
 217               	.LBE42:
 218               	.LBB45:
 219               	.LBB46:
 192:matrix.c      **** }
 193:matrix.c      **** 
 194:matrix.c      **** static void select_row(uint8_t row)
 195:matrix.c      **** {
 196:matrix.c      ****     // Output low(DDR:1, PORT:0) to select
 197:matrix.c      ****     switch (row) {
 220               		.loc 1 197 0
 221 001e D430      		cpi r29,lo8(4)
 222 0020 01F0      		breq .L12
 223 0022 00F4      		brsh .L16
 224 0024 D230      		cpi r29,lo8(2)
 225 0026 01F0      		breq .L10
 226 0028 00F4      		brsh .L11
 227 002a D130      		cpi r29,lo8(1)
 228 002c 01F4      		brne .L8
 229 002e 00C0      		rjmp .L9
 230               	.L16:
 231 0030 D630      		cpi r29,lo8(6)
 232 0032 01F0      		breq .L14
 233 0034 00F0      		brlo .L13
 234 0036 D730      		cpi r29,lo8(7)
 235 0038 01F4      		brne .L8
 198:matrix.c      ****         case 7:
 199:matrix.c      ****             DDRA  |= (1<<4);
 236               		.loc 1 199 0
 237 003a 0C9A      		sbi 0x1,4
 200:matrix.c      ****             PORTA &= ~(1<<4);
 238               		.loc 1 200 0
 239 003c 1498      		cbi 0x2,4
 240 003e 00C0      		rjmp .L17
 241               	.L14:
 201:matrix.c      ****             break;
 202:matrix.c      ****         case 6:
 203:matrix.c      ****             DDRA  |= (1<<5);
 242               		.loc 1 203 0
 243 0040 0D9A      		sbi 0x1,5
 204:matrix.c      ****             PORTA &= ~(1<<5);
 244               		.loc 1 204 0
 245 0042 1598      		cbi 0x2,5
 246 0044 00C0      		rjmp .L17
 247               	.L13:
 205:matrix.c      ****             break;
 206:matrix.c      ****         case 5:
 207:matrix.c      ****             DDRA  |= (1<<6);
 248               		.loc 1 207 0
 249 0046 0E9A      		sbi 0x1,6
 208:matrix.c      ****             PORTA &= ~(1<<6);
 250               		.loc 1 208 0
 251 0048 1698      		cbi 0x2,6
 252 004a 00C0      		rjmp .L17
 253               	.L12:
 209:matrix.c      ****             break;
 210:matrix.c      ****         case 4:
 211:matrix.c      ****             DDRA  |= (1<<7);
 254               		.loc 1 211 0
 255 004c 0F9A      		sbi 0x1,7
 212:matrix.c      ****             PORTA &= ~(1<<7);
 256               		.loc 1 212 0
 257 004e 1798      		cbi 0x2,7
 258 0050 00C0      		rjmp .L17
 259               	.L11:
 213:matrix.c      ****             break;
 214:matrix.c      ****         case 3:
 215:matrix.c      ****             DDRC  |= (1<<7);
 260               		.loc 1 215 0
 261 0052 3F9A      		sbi 0x7,7
 216:matrix.c      ****             PORTC &= ~(1<<7);
 262               		.loc 1 216 0
 263 0054 4798      		cbi 0x8,7
 264 0056 00C0      		rjmp .L17
 265               	.L10:
 217:matrix.c      ****             break;
 218:matrix.c      ****         case 2:
 219:matrix.c      ****             DDRC  |= (1<<6);
 266               		.loc 1 219 0
 267 0058 3E9A      		sbi 0x7,6
 220:matrix.c      ****             PORTC &= ~(1<<6);
 268               		.loc 1 220 0
 269 005a 4698      		cbi 0x8,6
 270 005c 00C0      		rjmp .L17
 271               	.L9:
 221:matrix.c      ****             break;
 222:matrix.c      ****         case 1:
 223:matrix.c      ****             DDRC  |= (1<<5);
 272               		.loc 1 223 0
 273 005e 3D9A      		sbi 0x7,5
 224:matrix.c      ****             PORTC &= ~(1<<5);
 274               		.loc 1 224 0
 275 0060 4598      		cbi 0x8,5
 276 0062 00C0      		rjmp .L17
 277               	.L8:
 225:matrix.c      ****             break;
 226:matrix.c      ****         case 0:
 227:matrix.c      ****             DDRC  |= (1<<4);
 278               		.loc 1 227 0
 279 0064 3C9A      		sbi 0x7,4
 228:matrix.c      ****             PORTC &= ~(1<<4);
 280               		.loc 1 228 0
 281 0066 4498      		cbi 0x8,4
 282               	.L17:
 283               	.LVL5:
 284               	.LBE46:
 285               	.LBE45:
 286               	.LBB47:
 287               	.LBB48:
 288               		.file 2 "/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h"
   1:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
   6:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
   9:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  12:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  17:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  21:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  33:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  35:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  38:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  41:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  42:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  46:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \code
  49:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  54:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     used.
  58:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  59:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  68:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  77:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  81:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** */
  82:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  83:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  87:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  88:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  93:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  94:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  97:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  98:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
 103:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 104:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /**
 105:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 107:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 109:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 112:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 114:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 120:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 125:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 129:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 132:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 140:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****  */
 141:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** void
 142:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** {
 144:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 153:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 156:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 159:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 164:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 166:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #else
 167:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	{
 172:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		{
 176:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		}
 180:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	}
 182:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	else
 183:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
 186:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** }
 187:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 188:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /**
 189:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 191:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 193:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 196:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 198:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 202:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   
 207:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 211:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****  
 214:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 222:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****  */
 223:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** void
 224:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** {
 226:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 235:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 238:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 241:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 246:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 289               		.loc 2 246 0
 290 0068 80E5      		ldi r24,lo8(80)
 291 006a 8A95      		1: dec r24
 292 006c 01F4      		brne 1b
 293               	.LBE48:
 294               	.LBE47:
 295               	.LBB49:
 296               	.LBB44:
 161:matrix.c      ****     return (PINB&(1<<3) ? 0 : (1<<0)) |
 297               		.loc 1 161 0
 298 006e 83B1      		in r24,0x3
 299 0070 8695      		lsr r24
 300 0072 8695      		lsr r24
 301 0074 8695      		lsr r24
 302 0076 8C27      		eor r24,r28
 303 0078 80FB      		bst r24,0
 304 007a AA24      		clr r10
 305 007c A0F8      		bld r10,0
 306 007e B12C      		mov r11,__zero_reg__
 162:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<1)) |
 307               		.loc 1 162 0
 308 0080 1A9B      		sbis 0x3,2
 309 0082 00C0      		rjmp .L45
 310 0084 20E0      		ldi r18,0
 311 0086 30E0      		ldi r19,0
 312 0088 00C0      		rjmp .L18
 313               	.L45:
 314 008a 22E0      		ldi r18,lo8(2)
 315 008c 30E0      		ldi r19,0
 316               	.L18:
 161:matrix.c      ****     return (PINB&(1<<3) ? 0 : (1<<0)) |
 317               		.loc 1 161 0
 318 008e C901      		movw r24,r18
 319 0090 8A29      		or r24,r10
 320 0092 9B29      		or r25,r11
 163:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<2)) |
 321               		.loc 1 163 0
 322 0094 199B      		sbis 0x3,1
 323 0096 00C0      		rjmp .L46
 324 0098 20E0      		ldi r18,0
 325 009a 30E0      		ldi r19,0
 326 009c 00C0      		rjmp .L19
 327               	.L46:
 328 009e 24E0      		ldi r18,lo8(4)
 329 00a0 30E0      		ldi r19,0
 330               	.L19:
 162:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<1)) |
 331               		.loc 1 162 0
 332 00a2 282B      		or r18,r24
 333 00a4 392B      		or r19,r25
 164:matrix.c      ****            (PINB&(1<<0) ? 0 : (1<<3)) |
 334               		.loc 1 164 0
 335 00a6 189B      		sbis 0x3,0
 336 00a8 00C0      		rjmp .L47
 337 00aa 80E0      		ldi r24,0
 338 00ac 90E0      		ldi r25,0
 339 00ae 00C0      		rjmp .L20
 340               	.L47:
 341 00b0 88E0      		ldi r24,lo8(8)
 342 00b2 90E0      		ldi r25,0
 343               	.L20:
 163:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<2)) |
 344               		.loc 1 163 0
 345 00b4 822B      		or r24,r18
 346 00b6 932B      		or r25,r19
 165:matrix.c      ****            (PINE&(1<<3) ? 0 : (1<<4)) |
 347               		.loc 1 165 0
 348 00b8 639B      		sbis 0xc,3
 349 00ba 00C0      		rjmp .L48
 350 00bc 40E0      		ldi r20,0
 351 00be 50E0      		ldi r21,0
 352 00c0 00C0      		rjmp .L21
 353               	.L48:
 354 00c2 40E1      		ldi r20,lo8(16)
 355 00c4 50E0      		ldi r21,0
 356               	.L21:
 164:matrix.c      ****            (PINB&(1<<0) ? 0 : (1<<3)) |
 357               		.loc 1 164 0
 358 00c6 482B      		or r20,r24
 359 00c8 592B      		or r21,r25
 166:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<<5)) |
 360               		.loc 1 166 0
 361 00ca 799B      		sbis 0xf,1
 362 00cc 00C0      		rjmp .L49
 363 00ce 20E0      		ldi r18,0
 364 00d0 30E0      		ldi r19,0
 365 00d2 00C0      		rjmp .L22
 366               	.L49:
 367 00d4 20E2      		ldi r18,lo8(32)
 368 00d6 30E0      		ldi r19,0
 369               	.L22:
 165:matrix.c      ****            (PINE&(1<<3) ? 0 : (1<<4)) |
 370               		.loc 1 165 0
 371 00d8 242B      		or r18,r20
 372 00da 352B      		or r19,r21
 167:matrix.c      ****            (PINF&(1<<2) ? 0 : (1<<6)) |
 373               		.loc 1 167 0
 374 00dc 7A9B      		sbis 0xf,2
 375 00de 00C0      		rjmp .L50
 376 00e0 80E0      		ldi r24,0
 377 00e2 90E0      		ldi r25,0
 378 00e4 00C0      		rjmp .L23
 379               	.L50:
 380 00e6 80E4      		ldi r24,lo8(64)
 381 00e8 90E0      		ldi r25,0
 382               	.L23:
 166:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<<5)) |
 383               		.loc 1 166 0
 384 00ea 282B      		or r18,r24
 385 00ec 392B      		or r19,r25
 168:matrix.c      ****            (PINF&(1<<3) ? 0 : (1<<7)) |
 386               		.loc 1 168 0
 387 00ee 7B9B      		sbis 0xf,3
 388 00f0 00C0      		rjmp .L51
 389 00f2 60E0      		ldi r22,0
 390 00f4 70E0      		ldi r23,0
 391 00f6 00C0      		rjmp .L24
 392               	.L51:
 393 00f8 60E8      		ldi r22,lo8(-128)
 394 00fa 70E0      		ldi r23,0
 395               	.L24:
 167:matrix.c      ****            (PINF&(1<<2) ? 0 : (1<<6)) |
 396               		.loc 1 167 0
 397 00fc 262B      		or r18,r22
 398 00fe 372B      		or r19,r23
 169:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<8)) |
 399               		.loc 1 169 0
 400 0100 7C9B      		sbis 0xf,4
 401 0102 00C0      		rjmp .L52
 402 0104 40E0      		ldi r20,0
 403 0106 50E0      		ldi r21,0
 404 0108 00C0      		rjmp .L25
 405               	.L52:
 406 010a 40E0      		ldi r20,0
 407 010c 51E0      		ldi r21,lo8(1)
 408               	.L25:
 168:matrix.c      ****            (PINF&(1<<3) ? 0 : (1<<7)) |
 409               		.loc 1 168 0
 410 010e 242B      		or r18,r20
 411 0110 352B      		or r19,r21
 170:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<9)) |
 412               		.loc 1 170 0
 413 0112 7D9B      		sbis 0xf,5
 414 0114 00C0      		rjmp .L53
 415 0116 80E0      		ldi r24,0
 416 0118 90E0      		ldi r25,0
 417 011a 00C0      		rjmp .L26
 418               	.L53:
 419 011c 80E0      		ldi r24,0
 420 011e 92E0      		ldi r25,lo8(2)
 421               	.L26:
 169:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<8)) |
 422               		.loc 1 169 0
 423 0120 282B      		or r18,r24
 424 0122 392B      		or r19,r25
 171:matrix.c      ****            (PINF&(1<<6) ? 0 : (1<<10)) |
 425               		.loc 1 171 0
 426 0124 7E9B      		sbis 0xf,6
 427 0126 00C0      		rjmp .L54
 428 0128 80E0      		ldi r24,0
 429 012a 90E0      		ldi r25,0
 430 012c 00C0      		rjmp .L27
 431               	.L54:
 432 012e 80E0      		ldi r24,0
 433 0130 94E0      		ldi r25,lo8(4)
 434               	.L27:
 170:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<9)) |
 435               		.loc 1 170 0
 436 0132 282B      		or r18,r24
 437 0134 392B      		or r19,r25
 172:matrix.c      ****            (PINF&(1<<7) ? 0 : (1<<11)) |
 438               		.loc 1 172 0
 439 0136 8FB1      		in r24,0xf
 440 0138 9927      		clr r25
 441 013a 87FD      		sbrc r24,7
 442 013c 9095      		com r25
 443 013e 8095      		com r24
 444 0140 9095      		com r25
 445 0142 8827      		clr r24
 446 0144 990F      		lsl r25
 447 0146 881F      		rol r24
 448 0148 9927      		clr r25
 449 014a 982F      		mov r25,r24
 450 014c 8827      		clr r24
 451 014e 990F      		lsl r25
 452 0150 990F      		lsl r25
 453 0152 990F      		lsl r25
 171:matrix.c      ****            (PINF&(1<<6) ? 0 : (1<<10)) |
 454               		.loc 1 171 0
 455 0154 282B      		or r18,r24
 456 0156 392B      		or r19,r25
 173:matrix.c      ****            (PINA&(1<<0) ? 0 : (1<<12)) |
 457               		.loc 1 173 0
 458 0158 009B      		sbis 0,0
 459 015a 00C0      		rjmp .L56
 460 015c 40E0      		ldi r20,0
 461 015e 50E0      		ldi r21,0
 462 0160 00C0      		rjmp .L29
 463               	.L56:
 464 0162 40E0      		ldi r20,0
 465 0164 50E1      		ldi r21,lo8(16)
 466               	.L29:
 172:matrix.c      ****            (PINF&(1<<7) ? 0 : (1<<11)) |
 467               		.loc 1 172 0
 468 0166 242B      		or r18,r20
 469 0168 352B      		or r19,r21
 174:matrix.c      ****            (PINA&(1<<1) ? 0 : (1<<13)) |
 470               		.loc 1 174 0
 471 016a 019B      		sbis 0,1
 472 016c 00C0      		rjmp .L57
 473 016e 40E0      		ldi r20,0
 474 0170 50E0      		ldi r21,0
 475 0172 00C0      		rjmp .L30
 476               	.L57:
 477 0174 40E0      		ldi r20,0
 478 0176 50E2      		ldi r21,lo8(32)
 479               	.L30:
 173:matrix.c      ****            (PINA&(1<<0) ? 0 : (1<<12)) |
 480               		.loc 1 173 0
 481 0178 242B      		or r18,r20
 482 017a 352B      		or r19,r21
 175:matrix.c      ****            (PINA&(1<<2) ? 0 : (1<<14)) |
 483               		.loc 1 175 0
 484 017c 029B      		sbis 0,2
 485 017e 00C0      		rjmp .L58
 486 0180 80E0      		ldi r24,0
 487 0182 90E0      		ldi r25,0
 488 0184 00C0      		rjmp .L31
 489               	.L58:
 490 0186 80E0      		ldi r24,0
 491 0188 90E4      		ldi r25,lo8(64)
 492               	.L31:
 174:matrix.c      ****            (PINA&(1<<1) ? 0 : (1<<13)) |
 493               		.loc 1 174 0
 494 018a 282B      		or r18,r24
 495 018c 392B      		or r19,r25
 176:matrix.c      ****            (PINA&(1<<3) ? 0 : (1<<15));
 496               		.loc 1 176 0
 497 018e 039B      		sbis 0,3
 498 0190 00C0      		rjmp .L59
 499 0192 80E0      		ldi r24,0
 500 0194 90E0      		ldi r25,0
 501 0196 00C0      		rjmp .L32
 502               	.L59:
 503 0198 80E0      		ldi r24,0
 504 019a 90E8      		ldi r25,lo8(-128)
 505               	.L32:
 175:matrix.c      ****            (PINA&(1<<2) ? 0 : (1<<14)) |
 506               		.loc 1 175 0
 507 019c 282B      		or r18,r24
 508 019e 392B      		or r19,r25
 509               	.LBE44:
 510               	.LBE49:
  81:matrix.c      ****         if (matrix_debouncing[i] != cols) {
 511               		.loc 1 81 0
 512 01a0 D701      		movw r26,r14
 513 01a2 8D91      		ld r24,X+
 514 01a4 9C91      		ld r25,X
 515 01a6 1197      		sbiw r26,1
 516 01a8 8217      		cp r24,r18
 517 01aa 9307      		cpc r25,r19
 518 01ac 01F0      		breq .L33
  82:matrix.c      ****             matrix_debouncing[i] = cols;
 519               		.loc 1 82 0
 520 01ae 2D93      		st X+,r18
 521 01b0 3C93      		st X,r19
  83:matrix.c      ****             if (debouncing) {
 522               		.loc 1 83 0
 523 01b2 8091 0000 		lds r24,debouncing
 524 01b6 8823      		tst r24
 525 01b8 01F0      		breq .L35
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 526               		.loc 1 84 0
 527 01ba 8091 0000 		lds r24,debug_config
 528 01be 80FF      		sbrs r24,0
 529 01c0 00C0      		rjmp .L36
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 530               		.loc 1 84 0 is_stmt 0 discriminator 1
 531 01c2 80E0      		ldi r24,lo8(__c.1778)
 532 01c4 90E0      		ldi r25,hi8(__c.1778)
 533 01c6 0E94 0000 		call xputs
 534               	.LVL6:
 535               	.L36:
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 536               		.loc 1 84 0 discriminator 2
 537 01ca 8091 0000 		lds r24,debug_config
 538 01ce 80FF      		sbrs r24,0
 539 01d0 00C0      		rjmp .L37
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 540               		.loc 1 84 0 discriminator 1
 541 01d2 8091 0000 		lds r24,debouncing
 542 01d6 1F92      		push __zero_reg__
 543               	.LCFI8:
 544               		.cfi_def_cfa_offset 11
 545 01d8 8F93      		push r24
 546               	.LCFI9:
 547               		.cfi_def_cfa_offset 12
 548 01da 80E0      		ldi r24,lo8(__c.1780)
 549 01dc 90E0      		ldi r25,hi8(__c.1780)
 550 01de 9F93      		push r25
 551               	.LCFI10:
 552               		.cfi_def_cfa_offset 13
 553 01e0 8F93      		push r24
 554               	.LCFI11:
 555               		.cfi_def_cfa_offset 14
 556 01e2 0E94 0000 		call __xprintf
 557               	.LVL7:
 558 01e6 0F90      		pop __tmp_reg__
 559 01e8 0F90      		pop __tmp_reg__
 560 01ea 0F90      		pop __tmp_reg__
 561 01ec 0F90      		pop __tmp_reg__
 562               	.LCFI12:
 563               		.cfi_def_cfa_offset 10
 564               	.L37:
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 565               		.loc 1 84 0 discriminator 2
 566 01ee 8091 0000 		lds r24,debug_config
 567 01f2 80FF      		sbrs r24,0
 568 01f4 00C0      		rjmp .L35
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 569               		.loc 1 84 0 discriminator 1
 570 01f6 80E0      		ldi r24,lo8(__c.1782)
 571 01f8 90E0      		ldi r25,hi8(__c.1782)
 572 01fa 0E94 0000 		call xputs
 573               	.LVL8:
 574               	.L35:
  86:matrix.c      ****             debouncing = DEBOUNCE;
 575               		.loc 1 86 0 is_stmt 1
 576 01fe 85E0      		ldi r24,lo8(5)
 577 0200 8093 0000 		sts debouncing,r24
 578               	.L33:
  88:matrix.c      ****         unselect_rows();
 579               		.loc 1 88 0
 580 0204 0E94 0000 		call unselect_rows
 581               	.LVL9:
 582               	.LBE41:
  77:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 583               		.loc 1 77 0
 584 0208 DF5F      		subi r29,lo8(-(1))
 585               	.LVL10:
 586 020a B2E0      		ldi r27,2
 587 020c EB0E      		add r14,r27
 588 020e F11C      		adc r15,__zero_reg__
 589 0210 D830      		cpi r29,lo8(8)
 590 0212 01F0      		breq .+2
 591 0214 00C0      		rjmp .L39
 592               	.LBE40:
  91:matrix.c      ****     if (debouncing) {
 593               		.loc 1 91 0
 594 0216 8091 0000 		lds r24,debouncing
 595 021a 8823      		tst r24
 596 021c 01F0      		breq .L41
  92:matrix.c      ****         if (--debouncing) {
 597               		.loc 1 92 0
 598 021e 8150      		subi r24,lo8(-(-1))
 599 0220 8093 0000 		sts debouncing,r24
 600 0224 8823      		tst r24
 601 0226 01F0      		breq .L42
 602               	.LVL11:
 603               	.LBB50:
 604               	.LBB51:
 164:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 605               		.loc 2 164 0
 606 0228 EFEC      		ldi r30,lo8(1999)
 607 022a F7E0      		ldi r31,hi8(1999)
 608 022c 3197      		1: sbiw r30,1
 609 022e 01F4      		brne 1b
 610 0230 00C0      		rjmp .
 611 0232 0000      		nop
 612 0234 00C0      		rjmp .L41
 613               	.LVL12:
 614               	.L42:
 615 0236 E0E0      		ldi r30,lo8(matrix)
 616 0238 F0E0      		ldi r31,hi8(matrix)
 617               	.L43:
 618               	.LBE51:
 619               	.LBE50:
 620               	.LBB52:
  96:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 621               		.loc 1 96 0 discriminator 2
 622 023a D601      		movw r26,r12
 623 023c 8D91      		ld r24,X+
 624 023e 9D91      		ld r25,X+
 625 0240 6D01      		movw r12,r26
 626 0242 8193      		st Z+,r24
 627 0244 9193      		st Z+,r25
 628               	.LVL13:
  95:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 629               		.loc 1 95 0 discriminator 2
 630 0246 B0E0      		ldi r27,lo8(matrix_debouncing+16)
 631 0248 CB16      		cp r12,r27
 632 024a B0E0      		ldi r27,hi8(matrix_debouncing+16)
 633 024c DB06      		cpc r13,r27
 634 024e 01F4      		brne .L43
 635               	.L41:
 636               	.LBE52:
 102:matrix.c      **** }
 637               		.loc 1 102 0
 638 0250 81E0      		ldi r24,lo8(1)
 639               	/* epilogue start */
 640 0252 DF91      		pop r29
 641               	.LVL14:
 642 0254 CF91      		pop r28
 643 0256 FF90      		pop r15
 644 0258 EF90      		pop r14
 645 025a DF90      		pop r13
 646 025c CF90      		pop r12
 647 025e BF90      		pop r11
 648 0260 AF90      		pop r10
 649 0262 0895      		ret
 650               		.cfi_endproc
 651               	.LFE10:
 653               		.section	.text.matrix_is_modified,"ax",@progbits
 654               	.global	matrix_is_modified
 656               	matrix_is_modified:
 657               	.LFB11:
 105:matrix.c      **** {
 658               		.loc 1 105 0
 659               		.cfi_startproc
 660               	/* prologue: function */
 661               	/* frame size = 0 */
 662               	/* stack size = 0 */
 663               	.L__stack_usage = 0
 106:matrix.c      ****     if (debouncing) return false;
 664               		.loc 1 106 0
 665 0000 81E0      		ldi r24,lo8(1)
 666 0002 9091 0000 		lds r25,debouncing
 667 0006 9111      		cpse r25,__zero_reg__
 668 0008 80E0      		ldi r24,0
 669               	.L72:
 108:matrix.c      **** }
 670               		.loc 1 108 0
 671 000a 0895      		ret
 672               		.cfi_endproc
 673               	.LFE11:
 675               		.section	.text.matrix_is_on,"ax",@progbits
 676               	.global	matrix_is_on
 678               	matrix_is_on:
 679               	.LFB12:
 112:matrix.c      **** {
 680               		.loc 1 112 0
 681               		.cfi_startproc
 682               	.LVL15:
 683               	/* prologue: function */
 684               	/* frame size = 0 */
 685               	/* stack size = 0 */
 686               	.L__stack_usage = 0
 113:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 687               		.loc 1 113 0
 688 0000 21E0      		ldi r18,lo8(1)
 689 0002 30E0      		ldi r19,0
 690 0004 00C0      		rjmp 2f
 691               		1:
 692 0006 220F      		lsl r18
 693 0008 331F      		rol r19
 694               		2:
 695 000a 6A95      		dec r22
 696 000c 02F4      		brpl 1b
 697 000e E82F      		mov r30,r24
 698 0010 F0E0      		ldi r31,0
 699 0012 EE0F      		lsl r30
 700 0014 FF1F      		rol r31
 701 0016 E050      		subi r30,lo8(-(matrix))
 702 0018 F040      		sbci r31,hi8(-(matrix))
 703 001a 8081      		ld r24,Z
 704 001c 9181      		ldd r25,Z+1
 705               	.LVL16:
 706 001e 2823      		and r18,r24
 707 0020 3923      		and r19,r25
 708 0022 81E0      		ldi r24,lo8(1)
 709 0024 232B      		or r18,r19
 710 0026 01F4      		brne .L77
 711 0028 80E0      		ldi r24,0
 712               	.L77:
 114:matrix.c      **** }
 713               		.loc 1 114 0
 714 002a 0895      		ret
 715               		.cfi_endproc
 716               	.LFE12:
 718               		.section	.text.matrix_get_row,"ax",@progbits
 719               	.global	matrix_get_row
 721               	matrix_get_row:
 722               	.LFB13:
 118:matrix.c      **** {
 723               		.loc 1 118 0
 724               		.cfi_startproc
 725               	.LVL17:
 726               	/* prologue: function */
 727               	/* frame size = 0 */
 728               	/* stack size = 0 */
 729               	.L__stack_usage = 0
 119:matrix.c      ****     return matrix[row];
 730               		.loc 1 119 0
 731 0000 E82F      		mov r30,r24
 732 0002 F0E0      		ldi r31,0
 733 0004 EE0F      		lsl r30
 734 0006 FF1F      		rol r31
 735 0008 E050      		subi r30,lo8(-(matrix))
 736 000a F040      		sbci r31,hi8(-(matrix))
 120:matrix.c      **** }
 737               		.loc 1 120 0
 738 000c 8081      		ld r24,Z
 739               	.LVL18:
 740 000e 9181      		ldd r25,Z+1
 741 0010 0895      		ret
 742               		.cfi_endproc
 743               	.LFE13:
 745               		.section	.text.matrix_print,"ax",@progbits
 746               	.global	matrix_print
 748               	matrix_print:
 749               	.LFB14:
 123:matrix.c      **** {
 750               		.loc 1 123 0
 751               		.cfi_startproc
 752 0000 8F92      		push r8
 753               	.LCFI13:
 754               		.cfi_def_cfa_offset 3
 755               		.cfi_offset 8, -2
 756 0002 9F92      		push r9
 757               	.LCFI14:
 758               		.cfi_def_cfa_offset 4
 759               		.cfi_offset 9, -3
 760 0004 AF92      		push r10
 761               	.LCFI15:
 762               		.cfi_def_cfa_offset 5
 763               		.cfi_offset 10, -4
 764 0006 BF92      		push r11
 765               	.LCFI16:
 766               		.cfi_def_cfa_offset 6
 767               		.cfi_offset 11, -5
 768 0008 CF92      		push r12
 769               	.LCFI17:
 770               		.cfi_def_cfa_offset 7
 771               		.cfi_offset 12, -6
 772 000a DF92      		push r13
 773               	.LCFI18:
 774               		.cfi_def_cfa_offset 8
 775               		.cfi_offset 13, -7
 776 000c EF92      		push r14
 777               	.LCFI19:
 778               		.cfi_def_cfa_offset 9
 779               		.cfi_offset 14, -8
 780 000e FF92      		push r15
 781               	.LCFI20:
 782               		.cfi_def_cfa_offset 10
 783               		.cfi_offset 15, -9
 784               	/* prologue: function */
 785               	/* frame size = 0 */
 786               	/* stack size = 8 */
 787               	.L__stack_usage = 8
 124:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 788               		.loc 1 124 0
 789 0010 80E0      		ldi r24,lo8(__c.1804)
 790 0012 90E0      		ldi r25,hi8(__c.1804)
 791 0014 0E94 0000 		call xputs
 792 0018 B0E0      		ldi r27,lo8(matrix)
 793 001a AB2E      		mov r10,r27
 794 001c B0E0      		ldi r27,hi8(matrix)
 795 001e BB2E      		mov r11,r27
 796 0020 E12C      		mov r14,__zero_reg__
 797 0022 F12C      		mov r15,__zero_reg__
 798               	.LBB53:
 126:matrix.c      ****         phex(row); print(": ");
 799               		.loc 1 126 0
 800 0024 80E0      		ldi r24,lo8(__c.1807)
 801 0026 882E      		mov r8,r24
 802 0028 80E0      		ldi r24,hi8(__c.1807)
 803 002a 982E      		mov r9,r24
 127:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 804               		.loc 1 127 0
 805 002c 90E0      		ldi r25,lo8(__c.1811)
 806 002e C92E      		mov r12,r25
 807 0030 90E0      		ldi r25,hi8(__c.1811)
 808 0032 D92E      		mov r13,r25
 809               	.L80:
 126:matrix.c      ****         phex(row); print(": ");
 810               		.loc 1 126 0 discriminator 2
 811 0034 FF92      		push r15
 812               	.LCFI21:
 813               		.cfi_def_cfa_offset 11
 814 0036 EF92      		push r14
 815               	.LCFI22:
 816               		.cfi_def_cfa_offset 12
 817 0038 9F92      		push r9
 818               	.LCFI23:
 819               		.cfi_def_cfa_offset 13
 820 003a 8F92      		push r8
 821               	.LCFI24:
 822               		.cfi_def_cfa_offset 14
 823 003c 0E94 0000 		call __xprintf
 824 0040 80E0      		ldi r24,lo8(__c.1809)
 825 0042 90E0      		ldi r25,hi8(__c.1809)
 826 0044 0E94 0000 		call xputs
 127:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 827               		.loc 1 127 0 discriminator 2
 828 0048 F501      		movw r30,r10
 829 004a 8191      		ld r24,Z+
 830 004c 9191      		ld r25,Z+
 831 004e 5F01      		movw r10,r30
 832 0050 0E94 0000 		call bitrev16
 833 0054 9F93      		push r25
 834               	.LCFI25:
 835               		.cfi_def_cfa_offset 15
 836 0056 8F93      		push r24
 837               	.LCFI26:
 838               		.cfi_def_cfa_offset 16
 839 0058 DF92      		push r13
 840               	.LCFI27:
 841               		.cfi_def_cfa_offset 17
 842 005a CF92      		push r12
 843               	.LCFI28:
 844               		.cfi_def_cfa_offset 18
 845 005c 0E94 0000 		call __xprintf
 128:matrix.c      ****         print("\n");
 846               		.loc 1 128 0 discriminator 2
 847 0060 80E0      		ldi r24,lo8(__c.1813)
 848 0062 90E0      		ldi r25,hi8(__c.1813)
 849 0064 0E94 0000 		call xputs
 850 0068 FFEF      		ldi r31,-1
 851 006a EF1A      		sub r14,r31
 852 006c FF0A      		sbc r15,r31
 125:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 853               		.loc 1 125 0 discriminator 2
 854 006e 8DB7      		in r24,__SP_L__
 855 0070 9EB7      		in r25,__SP_H__
 856 0072 0896      		adiw r24,8
 857 0074 0FB6      		in __tmp_reg__,__SREG__
 858 0076 F894      		cli
 859 0078 9EBF      		out __SP_H__,r25
 860 007a 0FBE      		out __SREG__,__tmp_reg__
 861 007c 8DBF      		out __SP_L__,r24
 862               	.LCFI29:
 863               		.cfi_def_cfa_offset 10
 864 007e 98E0      		ldi r25,8
 865 0080 E916      		cp r14,r25
 866 0082 F104      		cpc r15,__zero_reg__
 867 0084 01F4      		brne .L80
 868               	/* epilogue start */
 869               	.LBE53:
 130:matrix.c      **** }
 870               		.loc 1 130 0
 871 0086 FF90      		pop r15
 872 0088 EF90      		pop r14
 873 008a DF90      		pop r13
 874 008c CF90      		pop r12
 875 008e BF90      		pop r11
 876 0090 AF90      		pop r10
 877 0092 9F90      		pop r9
 878 0094 8F90      		pop r8
 879 0096 0895      		ret
 880               		.cfi_endproc
 881               	.LFE14:
 883               		.section	.text.matrix_key_count,"ax",@progbits
 884               	.global	matrix_key_count
 886               	matrix_key_count:
 887               	.LFB15:
 133:matrix.c      **** {
 888               		.loc 1 133 0
 889               		.cfi_startproc
 890 0000 EF92      		push r14
 891               	.LCFI30:
 892               		.cfi_def_cfa_offset 3
 893               		.cfi_offset 14, -2
 894 0002 FF92      		push r15
 895               	.LCFI31:
 896               		.cfi_def_cfa_offset 4
 897               		.cfi_offset 15, -3
 898 0004 CF93      		push r28
 899               	.LCFI32:
 900               		.cfi_def_cfa_offset 5
 901               		.cfi_offset 28, -4
 902               	/* prologue: function */
 903               	/* frame size = 0 */
 904               	/* stack size = 3 */
 905               	.L__stack_usage = 3
 906               	.LVL19:
 907 0006 20E0      		ldi r18,lo8(matrix)
 908 0008 E22E      		mov r14,r18
 909 000a 20E0      		ldi r18,hi8(matrix)
 910 000c F22E      		mov r15,r18
 134:matrix.c      ****     uint8_t count = 0;
 911               		.loc 1 134 0
 912 000e C0E0      		ldi r28,0
 913               	.LVL20:
 914               	.L83:
 915               	.LBB54:
 136:matrix.c      ****         count += bitpop16(matrix[i]);
 916               		.loc 1 136 0 discriminator 2
 917 0010 F701      		movw r30,r14
 918 0012 8191      		ld r24,Z+
 919 0014 9191      		ld r25,Z+
 920 0016 7F01      		movw r14,r30
 921 0018 0E94 0000 		call bitpop16
 922               	.LVL21:
 923 001c C80F      		add r28,r24
 924               	.LVL22:
 135:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 925               		.loc 1 135 0 discriminator 2
 926 001e F0E0      		ldi r31,lo8(matrix+16)
 927 0020 EF16      		cp r14,r31
 928 0022 F0E0      		ldi r31,hi8(matrix+16)
 929 0024 FF06      		cpc r15,r31
 930 0026 01F4      		brne .L83
 931               	.LBE54:
 139:matrix.c      **** }
 932               		.loc 1 139 0
 933 0028 8C2F      		mov r24,r28
 934               	/* epilogue start */
 935 002a CF91      		pop r28
 936               	.LVL23:
 937 002c FF90      		pop r15
 938 002e EF90      		pop r14
 939 0030 0895      		ret
 940               		.cfi_endproc
 941               	.LFE15:
 943               		.section	.bss.matrix,"aw",@nobits
 946               	matrix:
 947 0000 0000 0000 		.zero	16
 947      0000 0000 
 947      0000 0000 
 947      0000 0000 
 948               		.section	.bss.matrix_debouncing,"aw",@nobits
 951               	matrix_debouncing:
 952 0000 0000 0000 		.zero	16
 952      0000 0000 
 952      0000 0000 
 952      0000 0000 
 953               		.section	.data.debouncing,"aw",@progbits
 956               	debouncing:
 957 0000 05        		.byte	5
 958               		.section	.progmem.data.__c.1778,"a",@progbits
 961               	__c.1778:
 962 0000 626F 756E 		.string	"bounce!: "
 962      6365 213A 
 962      2000 
 963               		.section	.progmem.data.__c.1780,"a",@progbits
 966               	__c.1780:
 967 0000 2530 3258 		.string	"%02X"
 967      00
 968               		.section	.progmem.data.__c.1782,"a",@progbits
 971               	__c.1782:
 972 0000 0A00      		.string	"\n"
 973               		.section	.progmem.data.__c.1804,"a",@progbits
 976               	__c.1804:
 977 0000 0A72 2F63 		.string	"\nr/c 0123456789ABCDEF\n"
 977      2030 3132 
 977      3334 3536 
 977      3738 3941 
 977      4243 4445 
 978               		.section	.progmem.data.__c.1807,"a",@progbits
 981               	__c.1807:
 982 0000 2530 3258 		.string	"%02X"
 982      00
 983               		.section	.progmem.data.__c.1809,"a",@progbits
 986               	__c.1809:
 987 0000 3A20 00   		.string	": "
 988               		.section	.progmem.data.__c.1811,"a",@progbits
 991               	__c.1811:
 992 0000 2530 3136 		.string	"%016b"
 992      6200 
 993               		.section	.progmem.data.__c.1813,"a",@progbits
 996               	__c.1813:
 997 0000 0A00      		.string	"\n"
 998               		.text
 999               	.Letext0:
 1000               		.file 3 "/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/stdint.h"
 1001               		.file 4 "../../../../tmk_core/common/debug.h"
 1002               		.file 5 "../../../../tmk_core/common/matrix.h"
 1003               		.file 6 "../../../../tmk_core/common/avr/xprintf.h"
 1004               		.file 7 "../../../../tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccGF6ox3.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccGF6ox3.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccGF6ox3.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccGF6ox3.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccGF6ox3.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccGF6ox3.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccGF6ox3.s:13     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/ccGF6ox3.s:45     .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccGF6ox3.s:62     .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccGF6ox3.s:79     .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccGF6ox3.s:946    .bss.matrix:0000000000000000 matrix
     /tmp/ccGF6ox3.s:951    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccGF6ox3.s:159    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccGF6ox3.s:956    .data.debouncing:0000000000000000 debouncing
     /tmp/ccGF6ox3.s:961    .progmem.data.__c.1778:0000000000000000 __c.1778
     /tmp/ccGF6ox3.s:966    .progmem.data.__c.1780:0000000000000000 __c.1780
     /tmp/ccGF6ox3.s:971    .progmem.data.__c.1782:0000000000000000 __c.1782
     /tmp/ccGF6ox3.s:656    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccGF6ox3.s:678    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccGF6ox3.s:721    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccGF6ox3.s:748    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccGF6ox3.s:976    .progmem.data.__c.1804:0000000000000000 __c.1804
     /tmp/ccGF6ox3.s:981    .progmem.data.__c.1807:0000000000000000 __c.1807
     /tmp/ccGF6ox3.s:991    .progmem.data.__c.1811:0000000000000000 __c.1811
     /tmp/ccGF6ox3.s:986    .progmem.data.__c.1809:0000000000000000 __c.1809
     /tmp/ccGF6ox3.s:996    .progmem.data.__c.1813:0000000000000000 __c.1813
     /tmp/ccGF6ox3.s:886    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
debug_config
xputs
__xprintf
bitrev16
bitpop16
__do_copy_data
__do_clear_bss
