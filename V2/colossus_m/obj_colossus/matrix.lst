   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.unselect_rows,"ax",@progbits
  13               	unselect_rows:
  14               	.LFB17:
  15               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "print.h"
  26:matrix.c      **** #include "debug.h"
  27:matrix.c      **** #include "util.h"
  28:matrix.c      **** #include "matrix.h"
  29:matrix.c      **** 
  30:matrix.c      **** 
  31:matrix.c      **** #ifndef DEBOUNCE
  32:matrix.c      **** #define DEBOUNCE	0
  33:matrix.c      **** #endif
  34:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  35:matrix.c      **** 
  36:matrix.c      **** /* matrix state(1:on, 0:off) */
  37:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  38:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  39:matrix.c      **** 
  40:matrix.c      **** static matrix_row_t read_cols(void);
  41:matrix.c      **** static void init_cols(void);
  42:matrix.c      **** static void unselect_rows(void);
  43:matrix.c      **** static void select_row(uint8_t row);
  44:matrix.c      **** 
  45:matrix.c      **** 
  46:matrix.c      **** inline
  47:matrix.c      **** uint8_t matrix_rows(void)
  48:matrix.c      **** {
  49:matrix.c      ****     return MATRIX_ROWS;
  50:matrix.c      **** }
  51:matrix.c      **** 
  52:matrix.c      **** inline
  53:matrix.c      **** uint8_t matrix_cols(void)
  54:matrix.c      **** {
  55:matrix.c      ****     return MATRIX_COLS;
  56:matrix.c      **** }
  57:matrix.c      **** 
  58:matrix.c      **** void matrix_init(void)
  59:matrix.c      **** {
  60:matrix.c      ****     // JTAG disable for PORT F. write JTD bit twice within four cycles.
  61:matrix.c      ****     MCUCR |= (1<<JTD);
  62:matrix.c      ****     MCUCR |= (1<<JTD);
  63:matrix.c      **** 
  64:matrix.c      ****     // initialize row and col
  65:matrix.c      ****     unselect_rows();
  66:matrix.c      ****     init_cols();
  67:matrix.c      **** 
  68:matrix.c      ****     // initialize matrix state: all keys off
  69:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  70:matrix.c      ****         matrix[i] = 0;
  71:matrix.c      ****         matrix_debouncing[i] = 0;
  72:matrix.c      ****     }
  73:matrix.c      **** }
  74:matrix.c      **** 
  75:matrix.c      **** uint8_t matrix_scan(void)
  76:matrix.c      **** {
  77:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  78:matrix.c      ****         select_row(i);
  79:matrix.c      ****         _delay_us(30);  // without this wait read unstable value.
  80:matrix.c      ****         matrix_row_t cols = read_cols();
  81:matrix.c      ****         if (matrix_debouncing[i] != cols) {
  82:matrix.c      ****             matrix_debouncing[i] = cols;
  83:matrix.c      ****             if (debouncing) {
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
  85:matrix.c      ****             }
  86:matrix.c      ****             debouncing = DEBOUNCE;
  87:matrix.c      ****         }
  88:matrix.c      ****         unselect_rows();
  89:matrix.c      ****     }
  90:matrix.c      **** 
  91:matrix.c      ****     if (debouncing) {
  92:matrix.c      ****         if (--debouncing) {
  93:matrix.c      ****             _delay_ms(1);
  94:matrix.c      ****         } else {
  95:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  96:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
  97:matrix.c      ****             }
  98:matrix.c      ****         }
  99:matrix.c      ****     }
 100:matrix.c      **** 
 101:matrix.c      ****     return 1;
 102:matrix.c      **** }
 103:matrix.c      **** 
 104:matrix.c      **** bool matrix_is_modified(void)
 105:matrix.c      **** {
 106:matrix.c      ****     if (debouncing) return false;
 107:matrix.c      ****     return true;
 108:matrix.c      **** }
 109:matrix.c      **** 
 110:matrix.c      **** inline
 111:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 112:matrix.c      **** {
 113:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 114:matrix.c      **** }
 115:matrix.c      **** 
 116:matrix.c      **** inline
 117:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 118:matrix.c      **** {
 119:matrix.c      ****     return matrix[row];
 120:matrix.c      **** }
 121:matrix.c      **** 
 122:matrix.c      **** void matrix_print(void)
 123:matrix.c      **** {
 124:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 125:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 126:matrix.c      ****         phex(row); print(": ");
 127:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 128:matrix.c      ****         print("\n");
 129:matrix.c      ****     }
 130:matrix.c      **** }
 131:matrix.c      **** 
 132:matrix.c      **** uint8_t matrix_key_count(void)
 133:matrix.c      **** {
 134:matrix.c      ****     uint8_t count = 0;
 135:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 136:matrix.c      ****         count += bitpop16(matrix[i]);
 137:matrix.c      ****     }
 138:matrix.c      ****     return count;
 139:matrix.c      **** }
 140:matrix.c      **** 
 141:matrix.c      **** 
 142:matrix.c      ****  /* Column pin configuration
 143:matrix.c      ****  * col:  0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f
 144:matrix.c      ****  * pin: B3  B2  B1  B0  E3  F1  F2  F3  F4  F5  F6  F7  A0  A1  A2  A3
 145:matrix.c      ****  */
 146:matrix.c      ****  static void  init_cols(void)
 147:matrix.c      **** {
 148:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 149:matrix.c      ****     DDRB  &= ~(1<<3 | 1<<2 | 1<<1 | 1<<0);
 150:matrix.c      ****     PORTB |=  (1<<3 | 1<<2 | 1<<1 | 1<<0);
 151:matrix.c      ****     DDRE  &= ~(1<<3);
 152:matrix.c      ****     PORTE |=  (1<<3);
 153:matrix.c      ****     DDRF  &= ~(1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 154:matrix.c      ****     PORTF |=  (1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 155:matrix.c      ****     DDRA  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3);
 156:matrix.c      ****     PORTA |=  (1<<0 | 1<<1 | 1<<2 | 1<<3);
 157:matrix.c      **** }
 158:matrix.c      **** 
 159:matrix.c      **** static matrix_row_t read_cols(void)
 160:matrix.c      **** {
 161:matrix.c      ****     return (PINB&(1<<3) ? 0 : (1<<0)) |
 162:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<1)) |
 163:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<2)) |
 164:matrix.c      ****            (PINB&(1<<0) ? 0 : (1<<3)) |
 165:matrix.c      ****            (PINE&(1<<3) ? 0 : (1<<4)) |
 166:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<<5)) |
 167:matrix.c      ****            (PINF&(1<<2) ? 0 : (1<<6)) |
 168:matrix.c      ****            (PINF&(1<<3) ? 0 : (1<<7)) |
 169:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<8)) |
 170:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<9)) |
 171:matrix.c      ****            (PINF&(1<<6) ? 0 : (1<<10)) |
 172:matrix.c      ****            (PINF&(1<<7) ? 0 : (1<<11)) |
 173:matrix.c      ****            (PINA&(1<<0) ? 0 : (1<<12)) |
 174:matrix.c      ****            (PINA&(1<<1) ? 0 : (1<<13)) |
 175:matrix.c      ****            (PINA&(1<<2) ? 0 : (1<<14)) |
 176:matrix.c      ****            (PINA&(1<<3) ? 0 : (1<<15));
 177:matrix.c      **** }
 178:matrix.c      **** 
 179:matrix.c      **** /* row pin configuration
 180:matrix.c      ****  * row: 0   1   2   3   4   5   6   7   
 181:matrix.c      ****  * pin: C4  C5  C6  C7  A7  A6  A5  A4
 182:matrix.c      ****  */
 183:matrix.c      **** 
 184:matrix.c      **** static void unselect_rows(void)
 185:matrix.c      **** {
  16               		.loc 1 185 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 186:matrix.c      ****     // Hi-Z(DDR:0, PORT:0) to unselect
 187:matrix.c      ****     DDRA  &= ~0b11110000;
  22               		.loc 1 187 0
  23 0000 81B1      		in r24,0x1
  24 0002 8F70      		andi r24,lo8(15)
  25 0004 81B9      		out 0x1,r24
 188:matrix.c      ****     PORTA &= ~0b11110000;
  26               		.loc 1 188 0
  27 0006 82B1      		in r24,0x2
  28 0008 8F70      		andi r24,lo8(15)
  29 000a 82B9      		out 0x2,r24
 189:matrix.c      ****     DDRC  &= ~0b11110000;
  30               		.loc 1 189 0
  31 000c 87B1      		in r24,0x7
  32 000e 8F70      		andi r24,lo8(15)
  33 0010 87B9      		out 0x7,r24
 190:matrix.c      ****     PORTC &= ~0b11110000;
  34               		.loc 1 190 0
  35 0012 88B1      		in r24,0x8
  36 0014 8F70      		andi r24,lo8(15)
  37 0016 88B9      		out 0x8,r24
  38 0018 0895      		ret
  39               		.cfi_endproc
  40               	.LFE17:
  42               		.section	.text.matrix_rows,"ax",@progbits
  43               	.global	matrix_rows
  45               	matrix_rows:
  46               	.LFB6:
  48:matrix.c      **** {
  47               		.loc 1 48 0
  48               		.cfi_startproc
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
  50:matrix.c      **** }
  53               		.loc 1 50 0
  54 0000 88E0      		ldi r24,lo8(8)
  55 0002 0895      		ret
  56               		.cfi_endproc
  57               	.LFE6:
  59               		.section	.text.matrix_cols,"ax",@progbits
  60               	.global	matrix_cols
  62               	matrix_cols:
  63               	.LFB7:
  54:matrix.c      **** {
  64               		.loc 1 54 0
  65               		.cfi_startproc
  66               	/* prologue: function */
  67               	/* frame size = 0 */
  68               	/* stack size = 0 */
  69               	.L__stack_usage = 0
  56:matrix.c      **** }
  70               		.loc 1 56 0
  71 0000 80E1      		ldi r24,lo8(16)
  72 0002 0895      		ret
  73               		.cfi_endproc
  74               	.LFE7:
  76               		.section	.text.matrix_init,"ax",@progbits
  77               	.global	matrix_init
  79               	matrix_init:
  80               	.LFB8:
  59:matrix.c      **** {
  81               		.loc 1 59 0
  82               		.cfi_startproc
  83               	/* prologue: function */
  84               	/* frame size = 0 */
  85               	/* stack size = 0 */
  86               	.L__stack_usage = 0
  61:matrix.c      ****     MCUCR |= (1<<JTD);
  87               		.loc 1 61 0
  88 0000 85B7      		in r24,0x35
  89 0002 8068      		ori r24,lo8(-128)
  90 0004 85BF      		out 0x35,r24
  62:matrix.c      ****     MCUCR |= (1<<JTD);
  91               		.loc 1 62 0
  92 0006 85B7      		in r24,0x35
  93 0008 8068      		ori r24,lo8(-128)
  94 000a 85BF      		out 0x35,r24
  65:matrix.c      ****     unselect_rows();
  95               		.loc 1 65 0
  96 000c 0E94 0000 		call unselect_rows
  97               	.LVL0:
  98               	.LBB12:
  99               	.LBB13:
 149:matrix.c      ****     DDRB  &= ~(1<<3 | 1<<2 | 1<<1 | 1<<0);
 100               		.loc 1 149 0
 101 0010 84B1      		in r24,0x4
 102 0012 807F      		andi r24,lo8(-16)
 103 0014 84B9      		out 0x4,r24
 150:matrix.c      ****     PORTB |=  (1<<3 | 1<<2 | 1<<1 | 1<<0);
 104               		.loc 1 150 0
 105 0016 85B1      		in r24,0x5
 106 0018 8F60      		ori r24,lo8(15)
 107 001a 85B9      		out 0x5,r24
 151:matrix.c      ****     DDRE  &= ~(1<<3);
 108               		.loc 1 151 0
 109 001c 6B98      		cbi 0xd,3
 152:matrix.c      ****     PORTE |=  (1<<3);
 110               		.loc 1 152 0
 111 001e 739A      		sbi 0xe,3
 153:matrix.c      ****     DDRF  &= ~(1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 112               		.loc 1 153 0
 113 0020 80B3      		in r24,0x10
 114 0022 8170      		andi r24,lo8(1)
 115 0024 80BB      		out 0x10,r24
 154:matrix.c      ****     PORTF |=  (1<<1 | 1<<2 | 1<<3 | 1<<4 | 1<<5 | 1<<6 | 1<<7);
 116               		.loc 1 154 0
 117 0026 81B3      		in r24,0x11
 118 0028 8E6F      		ori r24,lo8(-2)
 119 002a 81BB      		out 0x11,r24
 155:matrix.c      ****     DDRA  &= ~(1<<0 | 1<<1 | 1<<2 | 1<<3);
 120               		.loc 1 155 0
 121 002c 81B1      		in r24,0x1
 122 002e 807F      		andi r24,lo8(-16)
 123 0030 81B9      		out 0x1,r24
 156:matrix.c      ****     PORTA |=  (1<<0 | 1<<1 | 1<<2 | 1<<3);
 124               		.loc 1 156 0
 125 0032 82B1      		in r24,0x2
 126 0034 8F60      		ori r24,lo8(15)
 127 0036 82B9      		out 0x2,r24
 128               	.LVL1:
 129 0038 E0E0      		ldi r30,lo8(matrix)
 130 003a F0E0      		ldi r31,hi8(matrix)
 131 003c A0E0      		ldi r26,lo8(matrix_debouncing)
 132 003e B0E0      		ldi r27,hi8(matrix_debouncing)
 133               	.LVL2:
 134               	.L5:
 135               	.LBE13:
 136               	.LBE12:
 137               	.LBB14:
  70:matrix.c      ****         matrix[i] = 0;
 138               		.loc 1 70 0 discriminator 2
 139 0040 1192      		st Z+,__zero_reg__
 140 0042 1192      		st Z+,__zero_reg__
  71:matrix.c      ****         matrix_debouncing[i] = 0;
 141               		.loc 1 71 0 discriminator 2
 142 0044 1D92      		st X+,__zero_reg__
 143 0046 1D92      		st X+,__zero_reg__
  69:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 144               		.loc 1 69 0 discriminator 2
 145 0048 80E0      		ldi r24,hi8(matrix+16)
 146 004a E030      		cpi r30,lo8(matrix+16)
 147 004c F807      		cpc r31,r24
 148 004e 01F4      		brne .L5
 149               	/* epilogue start */
 150               	.LBE14:
  73:matrix.c      **** }
 151               		.loc 1 73 0
 152 0050 0895      		ret
 153               		.cfi_endproc
 154               	.LFE8:
 156               		.section	.text.matrix_scan,"ax",@progbits
 157               	.global	matrix_scan
 159               	matrix_scan:
 160               	.LFB9:
  76:matrix.c      **** {
 161               		.loc 1 76 0
 162               		.cfi_startproc
 163 0000 AF92      		push r10
 164               	.LCFI0:
 165               		.cfi_def_cfa_offset 3
 166               		.cfi_offset 10, -2
 167 0002 BF92      		push r11
 168               	.LCFI1:
 169               		.cfi_def_cfa_offset 4
 170               		.cfi_offset 11, -3
 171 0004 CF92      		push r12
 172               	.LCFI2:
 173               		.cfi_def_cfa_offset 5
 174               		.cfi_offset 12, -4
 175 0006 DF92      		push r13
 176               	.LCFI3:
 177               		.cfi_def_cfa_offset 6
 178               		.cfi_offset 13, -5
 179 0008 EF92      		push r14
 180               	.LCFI4:
 181               		.cfi_def_cfa_offset 7
 182               		.cfi_offset 14, -6
 183 000a FF92      		push r15
 184               	.LCFI5:
 185               		.cfi_def_cfa_offset 8
 186               		.cfi_offset 15, -7
 187 000c CF93      		push r28
 188               	.LCFI6:
 189               		.cfi_def_cfa_offset 9
 190               		.cfi_offset 28, -8
 191 000e DF93      		push r29
 192               	.LCFI7:
 193               		.cfi_def_cfa_offset 10
 194               		.cfi_offset 29, -9
 195               	/* prologue: function */
 196               	/* frame size = 0 */
 197               	/* stack size = 8 */
 198               	.L__stack_usage = 8
 199               	.LVL3:
 200 0010 60E0      		ldi r22,lo8(matrix_debouncing)
 201 0012 C62E      		mov r12,r22
 202 0014 60E0      		ldi r22,hi8(matrix_debouncing)
 203 0016 D62E      		mov r13,r22
  76:matrix.c      **** {
 204               		.loc 1 76 0
 205 0018 7601      		movw r14,r12
  77:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 206               		.loc 1 77 0
 207 001a C0E0      		ldi r28,0
 208               	.LBB26:
 209               	.LBB27:
 210               	.LBB28:
 211               	.LBB29:
 161:matrix.c      ****     return (PINB&(1<<3) ? 0 : (1<<0)) |
 212               		.loc 1 161 0
 213 001c D1E0      		ldi r29,lo8(1)
 214               	.LVL4:
 215               	.L34:
 216               	.LBE29:
 217               	.LBE28:
 218               	.LBB31:
 219               	.LBB32:
 191:matrix.c      **** }
 192:matrix.c      **** 
 193:matrix.c      **** static void select_row(uint8_t row)
 194:matrix.c      **** {
 195:matrix.c      ****     // Output low(DDR:1, PORT:0) to select
 196:matrix.c      ****     switch (row) {
 220               		.loc 1 196 0
 221 001e C430      		cpi r28,lo8(4)
 222 0020 01F0      		breq .L12
 223 0022 00F4      		brsh .L16
 224 0024 C230      		cpi r28,lo8(2)
 225 0026 01F0      		breq .L10
 226 0028 00F4      		brsh .L11
 227 002a C130      		cpi r28,lo8(1)
 228 002c 01F4      		brne .L8
 229 002e 00C0      		rjmp .L9
 230               	.L16:
 231 0030 C630      		cpi r28,lo8(6)
 232 0032 01F0      		breq .L14
 233 0034 00F0      		brlo .L13
 234 0036 C730      		cpi r28,lo8(7)
 235 0038 01F4      		brne .L8
 197:matrix.c      ****         case 7:
 198:matrix.c      ****             DDRA  |= (1<<4);
 236               		.loc 1 198 0
 237 003a 0C9A      		sbi 0x1,4
 199:matrix.c      ****             PORTA &= ~(1<<4);
 238               		.loc 1 199 0
 239 003c 1498      		cbi 0x2,4
 240 003e 00C0      		rjmp .L17
 241               	.L14:
 200:matrix.c      ****             break;
 201:matrix.c      ****         case 6:
 202:matrix.c      ****             DDRA  |= (1<<5);
 242               		.loc 1 202 0
 243 0040 0D9A      		sbi 0x1,5
 203:matrix.c      ****             PORTA &= ~(1<<5);
 244               		.loc 1 203 0
 245 0042 1598      		cbi 0x2,5
 246 0044 00C0      		rjmp .L17
 247               	.L13:
 204:matrix.c      ****             break;
 205:matrix.c      ****         case 5:
 206:matrix.c      ****             DDRA  |= (1<<6);
 248               		.loc 1 206 0
 249 0046 0E9A      		sbi 0x1,6
 207:matrix.c      ****             PORTA &= ~(1<<6);
 250               		.loc 1 207 0
 251 0048 1698      		cbi 0x2,6
 252 004a 00C0      		rjmp .L17
 253               	.L12:
 208:matrix.c      ****             break;
 209:matrix.c      ****         case 4:
 210:matrix.c      ****             DDRA  |= (1<<7);
 254               		.loc 1 210 0
 255 004c 0F9A      		sbi 0x1,7
 211:matrix.c      ****             PORTA &= ~(1<<7);
 256               		.loc 1 211 0
 257 004e 1798      		cbi 0x2,7
 258 0050 00C0      		rjmp .L17
 259               	.L11:
 212:matrix.c      ****             break;
 213:matrix.c      ****         case 3:
 214:matrix.c      ****             DDRC  |= (1<<7);
 260               		.loc 1 214 0
 261 0052 3F9A      		sbi 0x7,7
 215:matrix.c      ****             PORTC &= ~(1<<7);
 262               		.loc 1 215 0
 263 0054 4798      		cbi 0x8,7
 264 0056 00C0      		rjmp .L17
 265               	.L10:
 216:matrix.c      ****             break;
 217:matrix.c      ****         case 2:
 218:matrix.c      ****             DDRC  |= (1<<6);
 266               		.loc 1 218 0
 267 0058 3E9A      		sbi 0x7,6
 219:matrix.c      ****             PORTC &= ~(1<<6);
 268               		.loc 1 219 0
 269 005a 4698      		cbi 0x8,6
 270 005c 00C0      		rjmp .L17
 271               	.L9:
 220:matrix.c      ****             break;
 221:matrix.c      ****         case 1:
 222:matrix.c      ****             DDRC  |= (1<<5);
 272               		.loc 1 222 0
 273 005e 3D9A      		sbi 0x7,5
 223:matrix.c      ****             PORTC &= ~(1<<5);
 274               		.loc 1 223 0
 275 0060 4598      		cbi 0x8,5
 276 0062 00C0      		rjmp .L17
 277               	.L8:
 224:matrix.c      ****             break;
 225:matrix.c      ****         case 0:
 226:matrix.c      ****             DDRC  |= (1<<4);
 278               		.loc 1 226 0
 279 0064 3C9A      		sbi 0x7,4
 227:matrix.c      ****             PORTC &= ~(1<<4);
 280               		.loc 1 227 0
 281 0066 4498      		cbi 0x8,4
 282               	.L17:
 283               	.LVL5:
 284               	.LBE32:
 285               	.LBE31:
 286               	.LBB33:
 287               	.LBB34:
 288               		.file 2 "/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h"
   1:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
   6:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
   9:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  12:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  17:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  21:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  33:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  35:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  38:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  41:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  42:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  46:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \code
  49:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  54:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     used.
  58:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  59:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  68:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  77:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  81:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** */
  82:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  83:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  87:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  88:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  93:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  94:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  97:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  98:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
 103:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 104:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /**
 105:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 107:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 109:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 112:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 114:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 120:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 125:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 129:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 132:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 140:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****  */
 141:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** void
 142:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** {
 144:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 153:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 156:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 159:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 164:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 166:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #else
 167:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	{
 172:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		{
 176:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		}
 180:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	}
 182:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	else
 183:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
 186:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** }
 187:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 188:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /**
 189:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 191:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 193:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 196:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 198:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 202:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   
 207:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 211:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****  
 214:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 222:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****  */
 223:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** void
 224:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** {
 226:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 235:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 238:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 241:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 246:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 289               		.loc 2 246 0
 290 0068 80EA      		ldi r24,lo8(-96)
 291 006a 8A95      		1: dec r24
 292 006c 01F4      		brne 1b
 293               	.LBE34:
 294               	.LBE33:
 295               	.LBB35:
 296               	.LBB30:
 161:matrix.c      ****     return (PINB&(1<<3) ? 0 : (1<<0)) |
 297               		.loc 1 161 0
 298 006e 83B1      		in r24,0x3
 299 0070 8695      		lsr r24
 300 0072 8695      		lsr r24
 301 0074 8695      		lsr r24
 302 0076 8D27      		eor r24,r29
 303 0078 80FB      		bst r24,0
 304 007a AA24      		clr r10
 305 007c A0F8      		bld r10,0
 306 007e B12C      		mov r11,__zero_reg__
 162:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<1)) |
 307               		.loc 1 162 0
 308 0080 1A9B      		sbis 0x3,2
 309 0082 00C0      		rjmp .L40
 310 0084 20E0      		ldi r18,0
 311 0086 30E0      		ldi r19,0
 312 0088 00C0      		rjmp .L18
 313               	.L40:
 314 008a 22E0      		ldi r18,lo8(2)
 315 008c 30E0      		ldi r19,0
 316               	.L18:
 161:matrix.c      ****     return (PINB&(1<<3) ? 0 : (1<<0)) |
 317               		.loc 1 161 0
 318 008e C901      		movw r24,r18
 319 0090 8A29      		or r24,r10
 320 0092 9B29      		or r25,r11
 163:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<2)) |
 321               		.loc 1 163 0
 322 0094 199B      		sbis 0x3,1
 323 0096 00C0      		rjmp .L41
 324 0098 20E0      		ldi r18,0
 325 009a 30E0      		ldi r19,0
 326 009c 00C0      		rjmp .L19
 327               	.L41:
 328 009e 24E0      		ldi r18,lo8(4)
 329 00a0 30E0      		ldi r19,0
 330               	.L19:
 162:matrix.c      ****            (PINB&(1<<2) ? 0 : (1<<1)) |
 331               		.loc 1 162 0
 332 00a2 282B      		or r18,r24
 333 00a4 392B      		or r19,r25
 164:matrix.c      ****            (PINB&(1<<0) ? 0 : (1<<3)) |
 334               		.loc 1 164 0
 335 00a6 189B      		sbis 0x3,0
 336 00a8 00C0      		rjmp .L42
 337 00aa 80E0      		ldi r24,0
 338 00ac 90E0      		ldi r25,0
 339 00ae 00C0      		rjmp .L20
 340               	.L42:
 341 00b0 88E0      		ldi r24,lo8(8)
 342 00b2 90E0      		ldi r25,0
 343               	.L20:
 163:matrix.c      ****            (PINB&(1<<1) ? 0 : (1<<2)) |
 344               		.loc 1 163 0
 345 00b4 822B      		or r24,r18
 346 00b6 932B      		or r25,r19
 165:matrix.c      ****            (PINE&(1<<3) ? 0 : (1<<4)) |
 347               		.loc 1 165 0
 348 00b8 639B      		sbis 0xc,3
 349 00ba 00C0      		rjmp .L43
 350 00bc 40E0      		ldi r20,0
 351 00be 50E0      		ldi r21,0
 352 00c0 00C0      		rjmp .L21
 353               	.L43:
 354 00c2 40E1      		ldi r20,lo8(16)
 355 00c4 50E0      		ldi r21,0
 356               	.L21:
 164:matrix.c      ****            (PINB&(1<<0) ? 0 : (1<<3)) |
 357               		.loc 1 164 0
 358 00c6 482B      		or r20,r24
 359 00c8 592B      		or r21,r25
 166:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<<5)) |
 360               		.loc 1 166 0
 361 00ca 799B      		sbis 0xf,1
 362 00cc 00C0      		rjmp .L44
 363 00ce 20E0      		ldi r18,0
 364 00d0 30E0      		ldi r19,0
 365 00d2 00C0      		rjmp .L22
 366               	.L44:
 367 00d4 20E2      		ldi r18,lo8(32)
 368 00d6 30E0      		ldi r19,0
 369               	.L22:
 165:matrix.c      ****            (PINE&(1<<3) ? 0 : (1<<4)) |
 370               		.loc 1 165 0
 371 00d8 242B      		or r18,r20
 372 00da 352B      		or r19,r21
 167:matrix.c      ****            (PINF&(1<<2) ? 0 : (1<<6)) |
 373               		.loc 1 167 0
 374 00dc 7A9B      		sbis 0xf,2
 375 00de 00C0      		rjmp .L45
 376 00e0 80E0      		ldi r24,0
 377 00e2 90E0      		ldi r25,0
 378 00e4 00C0      		rjmp .L23
 379               	.L45:
 380 00e6 80E4      		ldi r24,lo8(64)
 381 00e8 90E0      		ldi r25,0
 382               	.L23:
 166:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<<5)) |
 383               		.loc 1 166 0
 384 00ea 282B      		or r18,r24
 385 00ec 392B      		or r19,r25
 168:matrix.c      ****            (PINF&(1<<3) ? 0 : (1<<7)) |
 386               		.loc 1 168 0
 387 00ee 7B9B      		sbis 0xf,3
 388 00f0 00C0      		rjmp .L46
 389 00f2 60E0      		ldi r22,0
 390 00f4 70E0      		ldi r23,0
 391 00f6 00C0      		rjmp .L24
 392               	.L46:
 393 00f8 60E8      		ldi r22,lo8(-128)
 394 00fa 70E0      		ldi r23,0
 395               	.L24:
 167:matrix.c      ****            (PINF&(1<<2) ? 0 : (1<<6)) |
 396               		.loc 1 167 0
 397 00fc 262B      		or r18,r22
 398 00fe 372B      		or r19,r23
 169:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<8)) |
 399               		.loc 1 169 0
 400 0100 7C9B      		sbis 0xf,4
 401 0102 00C0      		rjmp .L47
 402 0104 40E0      		ldi r20,0
 403 0106 50E0      		ldi r21,0
 404 0108 00C0      		rjmp .L25
 405               	.L47:
 406 010a 40E0      		ldi r20,0
 407 010c 51E0      		ldi r21,lo8(1)
 408               	.L25:
 168:matrix.c      ****            (PINF&(1<<3) ? 0 : (1<<7)) |
 409               		.loc 1 168 0
 410 010e 242B      		or r18,r20
 411 0110 352B      		or r19,r21
 170:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<9)) |
 412               		.loc 1 170 0
 413 0112 7D9B      		sbis 0xf,5
 414 0114 00C0      		rjmp .L48
 415 0116 80E0      		ldi r24,0
 416 0118 90E0      		ldi r25,0
 417 011a 00C0      		rjmp .L26
 418               	.L48:
 419 011c 80E0      		ldi r24,0
 420 011e 92E0      		ldi r25,lo8(2)
 421               	.L26:
 169:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<8)) |
 422               		.loc 1 169 0
 423 0120 282B      		or r18,r24
 424 0122 392B      		or r19,r25
 171:matrix.c      ****            (PINF&(1<<6) ? 0 : (1<<10)) |
 425               		.loc 1 171 0
 426 0124 7E9B      		sbis 0xf,6
 427 0126 00C0      		rjmp .L49
 428 0128 80E0      		ldi r24,0
 429 012a 90E0      		ldi r25,0
 430 012c 00C0      		rjmp .L27
 431               	.L49:
 432 012e 80E0      		ldi r24,0
 433 0130 94E0      		ldi r25,lo8(4)
 434               	.L27:
 170:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<9)) |
 435               		.loc 1 170 0
 436 0132 282B      		or r18,r24
 437 0134 392B      		or r19,r25
 172:matrix.c      ****            (PINF&(1<<7) ? 0 : (1<<11)) |
 438               		.loc 1 172 0
 439 0136 8FB1      		in r24,0xf
 440 0138 9927      		clr r25
 441 013a 87FD      		sbrc r24,7
 442 013c 9095      		com r25
 443 013e 8095      		com r24
 444 0140 9095      		com r25
 445 0142 8827      		clr r24
 446 0144 990F      		lsl r25
 447 0146 881F      		rol r24
 448 0148 9927      		clr r25
 449 014a 982F      		mov r25,r24
 450 014c 8827      		clr r24
 451 014e 990F      		lsl r25
 452 0150 990F      		lsl r25
 453 0152 990F      		lsl r25
 171:matrix.c      ****            (PINF&(1<<6) ? 0 : (1<<10)) |
 454               		.loc 1 171 0
 455 0154 282B      		or r18,r24
 456 0156 392B      		or r19,r25
 173:matrix.c      ****            (PINA&(1<<0) ? 0 : (1<<12)) |
 457               		.loc 1 173 0
 458 0158 009B      		sbis 0,0
 459 015a 00C0      		rjmp .L51
 460 015c 40E0      		ldi r20,0
 461 015e 50E0      		ldi r21,0
 462 0160 00C0      		rjmp .L29
 463               	.L51:
 464 0162 40E0      		ldi r20,0
 465 0164 50E1      		ldi r21,lo8(16)
 466               	.L29:
 172:matrix.c      ****            (PINF&(1<<7) ? 0 : (1<<11)) |
 467               		.loc 1 172 0
 468 0166 242B      		or r18,r20
 469 0168 352B      		or r19,r21
 174:matrix.c      ****            (PINA&(1<<1) ? 0 : (1<<13)) |
 470               		.loc 1 174 0
 471 016a 019B      		sbis 0,1
 472 016c 00C0      		rjmp .L52
 473 016e 40E0      		ldi r20,0
 474 0170 50E0      		ldi r21,0
 475 0172 00C0      		rjmp .L30
 476               	.L52:
 477 0174 40E0      		ldi r20,0
 478 0176 50E2      		ldi r21,lo8(32)
 479               	.L30:
 173:matrix.c      ****            (PINA&(1<<0) ? 0 : (1<<12)) |
 480               		.loc 1 173 0
 481 0178 242B      		or r18,r20
 482 017a 352B      		or r19,r21
 175:matrix.c      ****            (PINA&(1<<2) ? 0 : (1<<14)) |
 483               		.loc 1 175 0
 484 017c 029B      		sbis 0,2
 485 017e 00C0      		rjmp .L53
 486 0180 80E0      		ldi r24,0
 487 0182 90E0      		ldi r25,0
 488 0184 00C0      		rjmp .L31
 489               	.L53:
 490 0186 80E0      		ldi r24,0
 491 0188 90E4      		ldi r25,lo8(64)
 492               	.L31:
 174:matrix.c      ****            (PINA&(1<<1) ? 0 : (1<<13)) |
 493               		.loc 1 174 0
 494 018a 282B      		or r18,r24
 495 018c 392B      		or r19,r25
 176:matrix.c      ****            (PINA&(1<<3) ? 0 : (1<<15));
 496               		.loc 1 176 0
 497 018e 039B      		sbis 0,3
 498 0190 00C0      		rjmp .L54
 499 0192 80E0      		ldi r24,0
 500 0194 90E0      		ldi r25,0
 501 0196 00C0      		rjmp .L32
 502               	.L54:
 503 0198 80E0      		ldi r24,0
 504 019a 90E8      		ldi r25,lo8(-128)
 505               	.L32:
 175:matrix.c      ****            (PINA&(1<<2) ? 0 : (1<<14)) |
 506               		.loc 1 175 0
 507 019c 282B      		or r18,r24
 508 019e 392B      		or r19,r25
 509               	.LBE30:
 510               	.LBE35:
  81:matrix.c      ****         if (matrix_debouncing[i] != cols) {
 511               		.loc 1 81 0
 512 01a0 D701      		movw r26,r14
 513 01a2 8D91      		ld r24,X+
 514 01a4 9C91      		ld r25,X
 515 01a6 1197      		sbiw r26,1
 516 01a8 8217      		cp r24,r18
 517 01aa 9307      		cpc r25,r19
 518 01ac 01F0      		breq .L33
  82:matrix.c      ****             matrix_debouncing[i] = cols;
 519               		.loc 1 82 0
 520 01ae 2D93      		st X+,r18
 521 01b0 3C93      		st X,r19
  86:matrix.c      ****             debouncing = DEBOUNCE;
 522               		.loc 1 86 0
 523 01b2 85E0      		ldi r24,lo8(5)
 524 01b4 8093 0000 		sts debouncing,r24
 525               	.L33:
  88:matrix.c      ****         unselect_rows();
 526               		.loc 1 88 0
 527 01b8 0E94 0000 		call unselect_rows
 528               	.LVL6:
 529               	.LBE27:
  77:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 530               		.loc 1 77 0
 531 01bc CF5F      		subi r28,lo8(-(1))
 532               	.LVL7:
 533 01be B2E0      		ldi r27,2
 534 01c0 EB0E      		add r14,r27
 535 01c2 F11C      		adc r15,__zero_reg__
 536 01c4 C830      		cpi r28,lo8(8)
 537 01c6 01F0      		breq .+2
 538 01c8 00C0      		rjmp .L34
 539               	.LBE26:
  91:matrix.c      ****     if (debouncing) {
 540               		.loc 1 91 0
 541 01ca 8091 0000 		lds r24,debouncing
 542 01ce 8823      		tst r24
 543 01d0 01F0      		breq .L36
  92:matrix.c      ****         if (--debouncing) {
 544               		.loc 1 92 0
 545 01d2 8150      		subi r24,lo8(-(-1))
 546 01d4 8093 0000 		sts debouncing,r24
 547 01d8 8823      		tst r24
 548 01da 01F0      		breq .L37
 549               	.LVL8:
 550               	.LBB36:
 551               	.LBB37:
 164:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 552               		.loc 2 164 0
 553 01dc EFE9      		ldi r30,lo8(3999)
 554 01de FFE0      		ldi r31,hi8(3999)
 555 01e0 3197      		1: sbiw r30,1
 556 01e2 01F4      		brne 1b
 557 01e4 00C0      		rjmp .
 558 01e6 0000      		nop
 559 01e8 00C0      		rjmp .L36
 560               	.LVL9:
 561               	.L37:
 562 01ea E0E0      		ldi r30,lo8(matrix)
 563 01ec F0E0      		ldi r31,hi8(matrix)
 564               	.L38:
 565               	.LBE37:
 566               	.LBE36:
 567               	.LBB38:
  96:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 568               		.loc 1 96 0 discriminator 2
 569 01ee D601      		movw r26,r12
 570 01f0 8D91      		ld r24,X+
 571 01f2 9D91      		ld r25,X+
 572 01f4 6D01      		movw r12,r26
 573 01f6 8193      		st Z+,r24
 574 01f8 9193      		st Z+,r25
 575               	.LVL10:
  95:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 576               		.loc 1 95 0 discriminator 2
 577 01fa B0E0      		ldi r27,lo8(matrix_debouncing+16)
 578 01fc CB16      		cp r12,r27
 579 01fe B0E0      		ldi r27,hi8(matrix_debouncing+16)
 580 0200 DB06      		cpc r13,r27
 581 0202 01F4      		brne .L38
 582               	.L36:
 583               	.LBE38:
 102:matrix.c      **** }
 584               		.loc 1 102 0
 585 0204 81E0      		ldi r24,lo8(1)
 586               	/* epilogue start */
 587 0206 DF91      		pop r29
 588 0208 CF91      		pop r28
 589               	.LVL11:
 590 020a FF90      		pop r15
 591 020c EF90      		pop r14
 592 020e DF90      		pop r13
 593 0210 CF90      		pop r12
 594 0212 BF90      		pop r11
 595 0214 AF90      		pop r10
 596 0216 0895      		ret
 597               		.cfi_endproc
 598               	.LFE9:
 600               		.section	.text.matrix_is_modified,"ax",@progbits
 601               	.global	matrix_is_modified
 603               	matrix_is_modified:
 604               	.LFB10:
 105:matrix.c      **** {
 605               		.loc 1 105 0
 606               		.cfi_startproc
 607               	/* prologue: function */
 608               	/* frame size = 0 */
 609               	/* stack size = 0 */
 610               	.L__stack_usage = 0
 106:matrix.c      ****     if (debouncing) return false;
 611               		.loc 1 106 0
 612 0000 81E0      		ldi r24,lo8(1)
 613 0002 9091 0000 		lds r25,debouncing
 614 0006 9111      		cpse r25,__zero_reg__
 615 0008 80E0      		ldi r24,0
 616               	.L58:
 108:matrix.c      **** }
 617               		.loc 1 108 0
 618 000a 0895      		ret
 619               		.cfi_endproc
 620               	.LFE10:
 622               		.section	.text.matrix_is_on,"ax",@progbits
 623               	.global	matrix_is_on
 625               	matrix_is_on:
 626               	.LFB11:
 112:matrix.c      **** {
 627               		.loc 1 112 0
 628               		.cfi_startproc
 629               	.LVL12:
 630               	/* prologue: function */
 631               	/* frame size = 0 */
 632               	/* stack size = 0 */
 633               	.L__stack_usage = 0
 113:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 634               		.loc 1 113 0
 635 0000 21E0      		ldi r18,lo8(1)
 636 0002 30E0      		ldi r19,0
 637 0004 00C0      		rjmp 2f
 638               		1:
 639 0006 220F      		lsl r18
 640 0008 331F      		rol r19
 641               		2:
 642 000a 6A95      		dec r22
 643 000c 02F4      		brpl 1b
 644 000e E82F      		mov r30,r24
 645 0010 F0E0      		ldi r31,0
 646 0012 EE0F      		lsl r30
 647 0014 FF1F      		rol r31
 648 0016 E050      		subi r30,lo8(-(matrix))
 649 0018 F040      		sbci r31,hi8(-(matrix))
 650 001a 8081      		ld r24,Z
 651 001c 9181      		ldd r25,Z+1
 652               	.LVL13:
 653 001e 2823      		and r18,r24
 654 0020 3923      		and r19,r25
 655 0022 81E0      		ldi r24,lo8(1)
 656 0024 232B      		or r18,r19
 657 0026 01F4      		brne .L63
 658 0028 80E0      		ldi r24,0
 659               	.L63:
 114:matrix.c      **** }
 660               		.loc 1 114 0
 661 002a 0895      		ret
 662               		.cfi_endproc
 663               	.LFE11:
 665               		.section	.text.matrix_get_row,"ax",@progbits
 666               	.global	matrix_get_row
 668               	matrix_get_row:
 669               	.LFB12:
 118:matrix.c      **** {
 670               		.loc 1 118 0
 671               		.cfi_startproc
 672               	.LVL14:
 673               	/* prologue: function */
 674               	/* frame size = 0 */
 675               	/* stack size = 0 */
 676               	.L__stack_usage = 0
 119:matrix.c      ****     return matrix[row];
 677               		.loc 1 119 0
 678 0000 E82F      		mov r30,r24
 679 0002 F0E0      		ldi r31,0
 680 0004 EE0F      		lsl r30
 681 0006 FF1F      		rol r31
 682 0008 E050      		subi r30,lo8(-(matrix))
 683 000a F040      		sbci r31,hi8(-(matrix))
 120:matrix.c      **** }
 684               		.loc 1 120 0
 685 000c 8081      		ld r24,Z
 686               	.LVL15:
 687 000e 9181      		ldd r25,Z+1
 688 0010 0895      		ret
 689               		.cfi_endproc
 690               	.LFE12:
 692               		.section	.text.matrix_print,"ax",@progbits
 693               	.global	matrix_print
 695               	matrix_print:
 696               	.LFB13:
 123:matrix.c      **** {
 697               		.loc 1 123 0
 698               		.cfi_startproc
 699               	/* prologue: function */
 700               	/* frame size = 0 */
 701               	/* stack size = 0 */
 702               	.L__stack_usage = 0
 703               	.LVL16:
 704 0000 0895      		ret
 705               		.cfi_endproc
 706               	.LFE13:
 708               		.section	.text.matrix_key_count,"ax",@progbits
 709               	.global	matrix_key_count
 711               	matrix_key_count:
 712               	.LFB14:
 133:matrix.c      **** {
 713               		.loc 1 133 0
 714               		.cfi_startproc
 133:matrix.c      **** {
 715               		.loc 1 133 0
 716 0000 EF92      		push r14
 717               	.LCFI8:
 718               		.cfi_def_cfa_offset 3
 719               		.cfi_offset 14, -2
 720 0002 FF92      		push r15
 721               	.LCFI9:
 722               		.cfi_def_cfa_offset 4
 723               		.cfi_offset 15, -3
 724 0004 CF93      		push r28
 725               	.LCFI10:
 726               		.cfi_def_cfa_offset 5
 727               		.cfi_offset 28, -4
 728               	/* prologue: function */
 729               	/* frame size = 0 */
 730               	/* stack size = 3 */
 731               	.L__stack_usage = 3
 732               	.LVL17:
 733 0006 B0E0      		ldi r27,lo8(matrix)
 734 0008 EB2E      		mov r14,r27
 735 000a B0E0      		ldi r27,hi8(matrix)
 736 000c FB2E      		mov r15,r27
 134:matrix.c      ****     uint8_t count = 0;
 737               		.loc 1 134 0
 738 000e C0E0      		ldi r28,0
 739               	.LVL18:
 740               	.L67:
 741               	.LBB39:
 136:matrix.c      ****         count += bitpop16(matrix[i]);
 742               		.loc 1 136 0 discriminator 2
 743 0010 F701      		movw r30,r14
 744 0012 8191      		ld r24,Z+
 745 0014 9191      		ld r25,Z+
 746 0016 7F01      		movw r14,r30
 747 0018 0E94 0000 		call bitpop16
 748               	.LVL19:
 749 001c C80F      		add r28,r24
 750               	.LVL20:
 135:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 751               		.loc 1 135 0 discriminator 2
 752 001e F0E0      		ldi r31,lo8(matrix+16)
 753 0020 EF16      		cp r14,r31
 754 0022 F0E0      		ldi r31,hi8(matrix+16)
 755 0024 FF06      		cpc r15,r31
 756 0026 01F4      		brne .L67
 757               	.LBE39:
 139:matrix.c      **** }
 758               		.loc 1 139 0
 759 0028 8C2F      		mov r24,r28
 760               	/* epilogue start */
 761 002a CF91      		pop r28
 762               	.LVL21:
 763 002c FF90      		pop r15
 764 002e EF90      		pop r14
 765 0030 0895      		ret
 766               		.cfi_endproc
 767               	.LFE14:
 769               		.section	.bss.matrix,"aw",@nobits
 772               	matrix:
 773 0000 0000 0000 		.zero	16
 773      0000 0000 
 773      0000 0000 
 773      0000 0000 
 774               		.section	.bss.matrix_debouncing,"aw",@nobits
 777               	matrix_debouncing:
 778 0000 0000 0000 		.zero	16
 778      0000 0000 
 778      0000 0000 
 778      0000 0000 
 779               		.section	.data.debouncing,"aw",@progbits
 782               	debouncing:
 783 0000 05        		.byte	5
 784               		.text
 785               	.Letext0:
 786               		.file 3 "/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/stdint.h"
 787               		.file 4 "../../../../tmk_core/common/matrix.h"
 788               		.file 5 "../../../../tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/cc4KEMvY.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc4KEMvY.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc4KEMvY.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc4KEMvY.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc4KEMvY.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc4KEMvY.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc4KEMvY.s:13     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/cc4KEMvY.s:45     .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/cc4KEMvY.s:62     .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/cc4KEMvY.s:79     .text.matrix_init:0000000000000000 matrix_init
     /tmp/cc4KEMvY.s:772    .bss.matrix:0000000000000000 matrix
     /tmp/cc4KEMvY.s:777    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/cc4KEMvY.s:159    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/cc4KEMvY.s:782    .data.debouncing:0000000000000000 debouncing
     /tmp/cc4KEMvY.s:603    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/cc4KEMvY.s:625    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/cc4KEMvY.s:668    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/cc4KEMvY.s:695    .text.matrix_print:0000000000000000 matrix_print
     /tmp/cc4KEMvY.s:711    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
bitpop16
__do_copy_data
__do_clear_bss
