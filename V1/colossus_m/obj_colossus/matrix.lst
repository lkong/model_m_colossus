   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.unselect_rows,"ax",@progbits
  13               	unselect_rows:
  14               	.LFB18:
  15               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "print.h"
  26:matrix.c      **** #include "debug.h"
  27:matrix.c      **** #include "util.h"
  28:matrix.c      **** #include "matrix.h"
  29:matrix.c      **** 
  30:matrix.c      **** 
  31:matrix.c      **** #ifndef DEBOUNCE
  32:matrix.c      **** #define DEBOUNCE	5
  33:matrix.c      **** #endif
  34:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  35:matrix.c      **** 
  36:matrix.c      **** /* matrix state(1:on, 0:off) */
  37:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  38:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  39:matrix.c      **** 
  40:matrix.c      **** static matrix_row_t read_cols(void);
  41:matrix.c      **** static void init_cols(void);
  42:matrix.c      **** static void unselect_rows(void);
  43:matrix.c      **** static void select_row(uint8_t row);
  44:matrix.c      **** 
  45:matrix.c      **** 
  46:matrix.c      **** inline
  47:matrix.c      **** uint8_t matrix_rows(void)
  48:matrix.c      **** {
  49:matrix.c      ****     return MATRIX_ROWS;
  50:matrix.c      **** }
  51:matrix.c      **** 
  52:matrix.c      **** inline
  53:matrix.c      **** uint8_t matrix_cols(void)
  54:matrix.c      **** {
  55:matrix.c      ****     return MATRIX_COLS;
  56:matrix.c      **** }
  57:matrix.c      **** 
  58:matrix.c      **** void matrix_init(void)
  59:matrix.c      **** {
  60:matrix.c      ****     // JTAG disable for PORT F. write JTD bit twice within four cycles.
  61:matrix.c      ****     MCUCR |= (1<<JTD);
  62:matrix.c      ****     MCUCR |= (1<<JTD);
  63:matrix.c      **** 
  64:matrix.c      ****     // initialize row and col
  65:matrix.c      ****     unselect_rows();
  66:matrix.c      ****     init_cols();
  67:matrix.c      **** 
  68:matrix.c      ****     // initialize matrix state: all keys off
  69:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  70:matrix.c      ****         matrix[i] = 0;
  71:matrix.c      ****         matrix_debouncing[i] = 0;
  72:matrix.c      ****     }
  73:matrix.c      **** }
  74:matrix.c      **** 
  75:matrix.c      **** uint8_t matrix_scan(void)
  76:matrix.c      **** {
  77:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  78:matrix.c      ****         select_row(i);
  79:matrix.c      ****         _delay_us(30);  // without this wait read unstable value.
  80:matrix.c      ****         matrix_row_t cols = read_cols();
  81:matrix.c      ****         if (matrix_debouncing[i] != cols) {
  82:matrix.c      ****             matrix_debouncing[i] = cols;
  83:matrix.c      ****             if (debouncing) {
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
  85:matrix.c      ****             }
  86:matrix.c      ****             debouncing = DEBOUNCE;
  87:matrix.c      ****         }
  88:matrix.c      ****         unselect_rows();
  89:matrix.c      ****     }
  90:matrix.c      **** 
  91:matrix.c      ****     if (debouncing) {
  92:matrix.c      ****         if (--debouncing) {
  93:matrix.c      ****             _delay_ms(1);
  94:matrix.c      ****         } else {
  95:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  96:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
  97:matrix.c      ****             }
  98:matrix.c      ****         }
  99:matrix.c      ****     }
 100:matrix.c      **** 
 101:matrix.c      ****     return 1;
 102:matrix.c      **** }
 103:matrix.c      **** 
 104:matrix.c      **** bool matrix_is_modified(void)
 105:matrix.c      **** {
 106:matrix.c      ****     if (debouncing) return false;
 107:matrix.c      ****     return true;
 108:matrix.c      **** }
 109:matrix.c      **** 
 110:matrix.c      **** inline
 111:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 112:matrix.c      **** {
 113:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 114:matrix.c      **** }
 115:matrix.c      **** 
 116:matrix.c      **** inline
 117:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 118:matrix.c      **** {
 119:matrix.c      ****     return matrix[row];
 120:matrix.c      **** }
 121:matrix.c      **** 
 122:matrix.c      **** void matrix_print(void)
 123:matrix.c      **** {
 124:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 125:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 126:matrix.c      ****         phex(row); print(": ");
 127:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 128:matrix.c      ****         print("\n");
 129:matrix.c      ****     }
 130:matrix.c      **** }
 131:matrix.c      **** 
 132:matrix.c      **** uint8_t matrix_key_count(void)
 133:matrix.c      **** {
 134:matrix.c      ****     uint8_t count = 0;
 135:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 136:matrix.c      ****         count += bitpop16(matrix[i]);
 137:matrix.c      ****     }
 138:matrix.c      ****     return count;
 139:matrix.c      **** }
 140:matrix.c      **** 
 141:matrix.c      **** 
 142:matrix.c      ****  /* Column pin configuration
 143:matrix.c      ****  * col: 0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f
 144:matrix.c      ****  * pin: a4  a5  a6  a7  c7  c6  c5  c4  c3  c2  c1  c0  e1  e0  d7  d5	
 145:matrix.c      ****  */
 146:matrix.c      ****  static void  init_cols(void)
 147:matrix.c      **** {
 148:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 149:matrix.c      ****     DDRA  &= ~(1<<4 | 1<<5 | 1<<6 | 1<<7);
 150:matrix.c      ****     PORTA |=  (1<<4 | 1<<5 | 1<<6 | 1<<7);
 151:matrix.c      ****     DDRC  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 152:matrix.c      ****     PORTC |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 153:matrix.c      ****     DDRE  &= ~(1<<1 | 1<<0);
 154:matrix.c      ****     PORTE |=  (1<<1 | 1<<0);
 155:matrix.c      ****     DDRD  &= ~(1<<7 | 1<<5);
 156:matrix.c      ****     PORTD |=  (1<<7 | 1<<5);  
 157:matrix.c      **** }
 158:matrix.c      **** 
 159:matrix.c      **** static matrix_row_t read_cols(void)
 160:matrix.c      **** {
 161:matrix.c      ****     return (PINA&(1<<4) ? 0 : (1<<0)) |
 162:matrix.c      ****            (PINA&(1<<5) ? 0 : (1<<1)) |
 163:matrix.c      ****            (PINA&(1<<6) ? 0 : (1<<2)) |
 164:matrix.c      ****            (PINA&(1<<7) ? 0 : (1<<3)) |
 165:matrix.c      ****            (PINC&(1<<7) ? 0 : (1<<4)) |
 166:matrix.c      ****            (PINC&(1<<6) ? 0 : (1<<5)) |
 167:matrix.c      ****            (PINC&(1<<5) ? 0 : (1<<6)) |
 168:matrix.c      ****            (PINC&(1<<4) ? 0 : (1<<7)) |
 169:matrix.c      ****            (PINC&(1<<3) ? 0 : (1<<8)) |
 170:matrix.c      ****            (PINC&(1<<2) ? 0 : (1<<9)) |
 171:matrix.c      ****            (PINC&(1<<1) ? 0 : (1<<10)) |
 172:matrix.c      ****            (PINC&(1<<0) ? 0 : (1<<11)) |
 173:matrix.c      ****            (PINE&(1<<1) ? 0 : (1<<12)) |
 174:matrix.c      ****            (PINE&(1<<0) ? 0 : (1<<13)) |
 175:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<<14)) |
 176:matrix.c      ****            (PIND&(1<<5) ? 0 : (1<<15));
 177:matrix.c      **** }
 178:matrix.c      **** 
 179:matrix.c      **** /* row pin configuration
 180:matrix.c      ****  * row: 0   1   2   3   4   5   6   7   
 181:matrix.c      ****  * pin: b5  b6  b7  e4  e5  d0  d1  d4    
 182:matrix.c      ****  */
 183:matrix.c      **** 
 184:matrix.c      **** static void unselect_rows(void)
 185:matrix.c      **** {
  16               		.loc 1 185 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 186:matrix.c      ****     // Hi-Z(DDR:0, PORT:0) to unselect
 187:matrix.c      ****     DDRB  &= ~0b11100000;
  22               		.loc 1 187 0
  23 0000 84B1      		in r24,0x4
  24 0002 8F71      		andi r24,lo8(31)
  25 0004 84B9      		out 0x4,r24
 188:matrix.c      ****     PORTB &= ~0b11100000;
  26               		.loc 1 188 0
  27 0006 85B1      		in r24,0x5
  28 0008 8F71      		andi r24,lo8(31)
  29 000a 85B9      		out 0x5,r24
 189:matrix.c      ****     DDRE  &= ~0b00110000;
  30               		.loc 1 189 0
  31 000c 8DB1      		in r24,0xd
  32 000e 8F7C      		andi r24,lo8(-49)
  33 0010 8DB9      		out 0xd,r24
 190:matrix.c      ****     PORTE &= ~0b00110000;
  34               		.loc 1 190 0
  35 0012 8EB1      		in r24,0xe
  36 0014 8F7C      		andi r24,lo8(-49)
  37 0016 8EB9      		out 0xe,r24
 191:matrix.c      ****     DDRD  &= ~0b00010011;
  38               		.loc 1 191 0
  39 0018 8AB1      		in r24,0xa
  40 001a 8C7E      		andi r24,lo8(-20)
  41 001c 8AB9      		out 0xa,r24
 192:matrix.c      ****     PORTD &= ~0b00010011;
  42               		.loc 1 192 0
  43 001e 8BB1      		in r24,0xb
  44 0020 8C7E      		andi r24,lo8(-20)
  45 0022 8BB9      		out 0xb,r24
  46 0024 0895      		ret
  47               		.cfi_endproc
  48               	.LFE18:
  50               		.section	.text.matrix_rows,"ax",@progbits
  51               	.global	matrix_rows
  53               	matrix_rows:
  54               	.LFB7:
  48:matrix.c      **** {
  55               		.loc 1 48 0
  56               		.cfi_startproc
  57               	/* prologue: function */
  58               	/* frame size = 0 */
  59               	/* stack size = 0 */
  60               	.L__stack_usage = 0
  50:matrix.c      **** }
  61               		.loc 1 50 0
  62 0000 88E0      		ldi r24,lo8(8)
  63 0002 0895      		ret
  64               		.cfi_endproc
  65               	.LFE7:
  67               		.section	.text.matrix_cols,"ax",@progbits
  68               	.global	matrix_cols
  70               	matrix_cols:
  71               	.LFB8:
  54:matrix.c      **** {
  72               		.loc 1 54 0
  73               		.cfi_startproc
  74               	/* prologue: function */
  75               	/* frame size = 0 */
  76               	/* stack size = 0 */
  77               	.L__stack_usage = 0
  56:matrix.c      **** }
  78               		.loc 1 56 0
  79 0000 80E1      		ldi r24,lo8(16)
  80 0002 0895      		ret
  81               		.cfi_endproc
  82               	.LFE8:
  84               		.section	.text.matrix_init,"ax",@progbits
  85               	.global	matrix_init
  87               	matrix_init:
  88               	.LFB9:
  59:matrix.c      **** {
  89               		.loc 1 59 0
  90               		.cfi_startproc
  91               	/* prologue: function */
  92               	/* frame size = 0 */
  93               	/* stack size = 0 */
  94               	.L__stack_usage = 0
  61:matrix.c      ****     MCUCR |= (1<<JTD);
  95               		.loc 1 61 0
  96 0000 85B7      		in r24,0x35
  97 0002 8068      		ori r24,lo8(-128)
  98 0004 85BF      		out 0x35,r24
  62:matrix.c      ****     MCUCR |= (1<<JTD);
  99               		.loc 1 62 0
 100 0006 85B7      		in r24,0x35
 101 0008 8068      		ori r24,lo8(-128)
 102 000a 85BF      		out 0x35,r24
  65:matrix.c      ****     unselect_rows();
 103               		.loc 1 65 0
 104 000c 0E94 0000 		call unselect_rows
 105               	.LVL0:
 106               	.LBB23:
 107               	.LBB24:
 149:matrix.c      ****     DDRA  &= ~(1<<4 | 1<<5 | 1<<6 | 1<<7);
 108               		.loc 1 149 0
 109 0010 81B1      		in r24,0x1
 110 0012 8F70      		andi r24,lo8(15)
 111 0014 81B9      		out 0x1,r24
 150:matrix.c      ****     PORTA |=  (1<<4 | 1<<5 | 1<<6 | 1<<7);
 112               		.loc 1 150 0
 113 0016 82B1      		in r24,0x2
 114 0018 806F      		ori r24,lo8(-16)
 115 001a 82B9      		out 0x2,r24
 151:matrix.c      ****     DDRC  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 116               		.loc 1 151 0
 117 001c 87B1      		in r24,0x7
 118 001e 17B8      		out 0x7,__zero_reg__
 152:matrix.c      ****     PORTC |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 119               		.loc 1 152 0
 120 0020 88B1      		in r24,0x8
 121 0022 8FEF      		ldi r24,lo8(-1)
 122 0024 88B9      		out 0x8,r24
 153:matrix.c      ****     DDRE  &= ~(1<<1 | 1<<0);
 123               		.loc 1 153 0
 124 0026 8DB1      		in r24,0xd
 125 0028 8C7F      		andi r24,lo8(-4)
 126 002a 8DB9      		out 0xd,r24
 154:matrix.c      ****     PORTE |=  (1<<1 | 1<<0);
 127               		.loc 1 154 0
 128 002c 8EB1      		in r24,0xe
 129 002e 8360      		ori r24,lo8(3)
 130 0030 8EB9      		out 0xe,r24
 155:matrix.c      ****     DDRD  &= ~(1<<7 | 1<<5);
 131               		.loc 1 155 0
 132 0032 8AB1      		in r24,0xa
 133 0034 8F75      		andi r24,lo8(95)
 134 0036 8AB9      		out 0xa,r24
 156:matrix.c      ****     PORTD |=  (1<<7 | 1<<5);  
 135               		.loc 1 156 0
 136 0038 8BB1      		in r24,0xb
 137 003a 806A      		ori r24,lo8(-96)
 138 003c 8BB9      		out 0xb,r24
 139               	.LVL1:
 140 003e E0E0      		ldi r30,lo8(matrix)
 141 0040 F0E0      		ldi r31,hi8(matrix)
 142 0042 A0E0      		ldi r26,lo8(matrix_debouncing)
 143 0044 B0E0      		ldi r27,hi8(matrix_debouncing)
 144               	.LVL2:
 145               	.L5:
 146               	.LBE24:
 147               	.LBE23:
 148               	.LBB25:
  70:matrix.c      ****         matrix[i] = 0;
 149               		.loc 1 70 0 discriminator 2
 150 0046 1192      		st Z+,__zero_reg__
 151 0048 1192      		st Z+,__zero_reg__
  71:matrix.c      ****         matrix_debouncing[i] = 0;
 152               		.loc 1 71 0 discriminator 2
 153 004a 1D92      		st X+,__zero_reg__
 154 004c 1D92      		st X+,__zero_reg__
  69:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 155               		.loc 1 69 0 discriminator 2
 156 004e 80E0      		ldi r24,hi8(matrix+16)
 157 0050 E030      		cpi r30,lo8(matrix+16)
 158 0052 F807      		cpc r31,r24
 159 0054 01F4      		brne .L5
 160               	/* epilogue start */
 161               	.LBE25:
  73:matrix.c      **** }
 162               		.loc 1 73 0
 163 0056 0895      		ret
 164               		.cfi_endproc
 165               	.LFE9:
 167               		.section	.text.matrix_scan,"ax",@progbits
 168               	.global	matrix_scan
 170               	matrix_scan:
 171               	.LFB10:
  76:matrix.c      **** {
 172               		.loc 1 76 0
 173               		.cfi_startproc
 174 0000 AF92      		push r10
 175               	.LCFI0:
 176               		.cfi_def_cfa_offset 3
 177               		.cfi_offset 10, -2
 178 0002 BF92      		push r11
 179               	.LCFI1:
 180               		.cfi_def_cfa_offset 4
 181               		.cfi_offset 11, -3
 182 0004 CF92      		push r12
 183               	.LCFI2:
 184               		.cfi_def_cfa_offset 5
 185               		.cfi_offset 12, -4
 186 0006 DF92      		push r13
 187               	.LCFI3:
 188               		.cfi_def_cfa_offset 6
 189               		.cfi_offset 13, -5
 190 0008 EF92      		push r14
 191               	.LCFI4:
 192               		.cfi_def_cfa_offset 7
 193               		.cfi_offset 14, -6
 194 000a FF92      		push r15
 195               	.LCFI5:
 196               		.cfi_def_cfa_offset 8
 197               		.cfi_offset 15, -7
 198 000c 1F93      		push r17
 199               	.LCFI6:
 200               		.cfi_def_cfa_offset 9
 201               		.cfi_offset 17, -8
 202 000e CF93      		push r28
 203               	.LCFI7:
 204               		.cfi_def_cfa_offset 10
 205               		.cfi_offset 28, -9
 206 0010 DF93      		push r29
 207               	.LCFI8:
 208               		.cfi_def_cfa_offset 11
 209               		.cfi_offset 29, -10
 210               	/* prologue: function */
 211               	/* frame size = 0 */
 212               	/* stack size = 9 */
 213               	.L__stack_usage = 9
 214               	.LVL3:
 215 0012 A0E0      		ldi r26,lo8(matrix_debouncing)
 216 0014 CA2E      		mov r12,r26
 217 0016 A0E0      		ldi r26,hi8(matrix_debouncing)
 218 0018 DA2E      		mov r13,r26
  76:matrix.c      **** {
 219               		.loc 1 76 0
 220 001a 7601      		movw r14,r12
  77:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 221               		.loc 1 77 0
 222 001c 10E0      		ldi r17,0
 223               	.LBB40:
 224               	.LBB41:
 225               	.LBB42:
 226               	.LBB43:
 161:matrix.c      ****     return (PINA&(1<<4) ? 0 : (1<<0)) |
 227               		.loc 1 161 0
 228 001e C1E0      		ldi r28,lo8(1)
 229               	.LBE43:
 230               	.LBE42:
  86:matrix.c      ****             debouncing = DEBOUNCE;
 231               		.loc 1 86 0
 232 0020 D5E0      		ldi r29,lo8(5)
 233               	.LVL4:
 234               	.L39:
 235               	.LBB45:
 236               	.LBB46:
 193:matrix.c      **** }
 194:matrix.c      **** 
 195:matrix.c      **** static void select_row(uint8_t row)
 196:matrix.c      **** {
 197:matrix.c      ****     // Output low(DDR:1, PORT:0) to select
 198:matrix.c      ****     switch (row) {
 237               		.loc 1 198 0
 238 0022 1430      		cpi r17,lo8(4)
 239 0024 01F0      		breq .L12
 240 0026 00F4      		brsh .L16
 241 0028 1230      		cpi r17,lo8(2)
 242 002a 01F0      		breq .L10
 243 002c 00F4      		brsh .L11
 244 002e 1130      		cpi r17,lo8(1)
 245 0030 01F4      		brne .L8
 246 0032 00C0      		rjmp .L9
 247               	.L16:
 248 0034 1630      		cpi r17,lo8(6)
 249 0036 01F0      		breq .L14
 250 0038 00F0      		brlo .L13
 251 003a 1730      		cpi r17,lo8(7)
 252 003c 01F4      		brne .L8
 199:matrix.c      ****         case 7:
 200:matrix.c      ****             DDRD  |= (1<<4);
 253               		.loc 1 200 0
 254 003e 549A      		sbi 0xa,4
 201:matrix.c      ****             PORTD &= ~(1<<4);
 255               		.loc 1 201 0
 256 0040 5C98      		cbi 0xb,4
 257 0042 00C0      		rjmp .L17
 258               	.L14:
 202:matrix.c      ****             break;
 203:matrix.c      ****         case 6:
 204:matrix.c      ****             DDRD  |= (1<<1);
 259               		.loc 1 204 0
 260 0044 519A      		sbi 0xa,1
 205:matrix.c      ****             PORTD &= ~(1<<1);
 261               		.loc 1 205 0
 262 0046 5998      		cbi 0xb,1
 263 0048 00C0      		rjmp .L17
 264               	.L13:
 206:matrix.c      ****             break;
 207:matrix.c      ****         case 5:
 208:matrix.c      ****             DDRD  |= (1<<0);
 265               		.loc 1 208 0
 266 004a 509A      		sbi 0xa,0
 209:matrix.c      ****             PORTD &= ~(1<<0);
 267               		.loc 1 209 0
 268 004c 5898      		cbi 0xb,0
 269 004e 00C0      		rjmp .L17
 270               	.L12:
 210:matrix.c      ****             break;
 211:matrix.c      ****         case 4:
 212:matrix.c      ****             DDRE  |= (1<<5);
 271               		.loc 1 212 0
 272 0050 6D9A      		sbi 0xd,5
 213:matrix.c      ****             PORTE &= ~(1<<5);
 273               		.loc 1 213 0
 274 0052 7598      		cbi 0xe,5
 275 0054 00C0      		rjmp .L17
 276               	.L11:
 214:matrix.c      ****             break;
 215:matrix.c      ****         case 3:
 216:matrix.c      ****             DDRE  |= (1<<4);
 277               		.loc 1 216 0
 278 0056 6C9A      		sbi 0xd,4
 217:matrix.c      ****             PORTE &= ~(1<<4);
 279               		.loc 1 217 0
 280 0058 7498      		cbi 0xe,4
 281 005a 00C0      		rjmp .L17
 282               	.L10:
 218:matrix.c      ****             break;
 219:matrix.c      ****         case 2:
 220:matrix.c      ****             DDRB  |= (1<<7);
 283               		.loc 1 220 0
 284 005c 279A      		sbi 0x4,7
 221:matrix.c      ****             PORTB &= ~(1<<7);
 285               		.loc 1 221 0
 286 005e 2F98      		cbi 0x5,7
 287 0060 00C0      		rjmp .L17
 288               	.L9:
 222:matrix.c      ****             break;
 223:matrix.c      ****         case 1:
 224:matrix.c      ****             DDRB  |= (1<<6);
 289               		.loc 1 224 0
 290 0062 269A      		sbi 0x4,6
 225:matrix.c      ****             PORTB &= ~(1<<6);
 291               		.loc 1 225 0
 292 0064 2E98      		cbi 0x5,6
 293 0066 00C0      		rjmp .L17
 294               	.L8:
 226:matrix.c      ****             break;
 227:matrix.c      ****         case 0:
 228:matrix.c      ****             DDRB  |= (1<<5);
 295               		.loc 1 228 0
 296 0068 259A      		sbi 0x4,5
 229:matrix.c      ****             PORTB &= ~(1<<5);
 297               		.loc 1 229 0
 298 006a 2D98      		cbi 0x5,5
 299               	.L17:
 300               	.LVL5:
 301               	.LBE46:
 302               	.LBE45:
 303               	.LBB47:
 304               	.LBB48:
 305               		.file 2 "/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h"
   1:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
   6:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
   9:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  12:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  17:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  21:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  33:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  35:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  38:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  41:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  42:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  46:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \code
  49:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  54:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     used.
  58:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  59:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  68:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  77:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  81:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** */
  82:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  83:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  87:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  88:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  93:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  94:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  97:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  98:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
 103:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 104:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /**
 105:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 107:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 109:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 112:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 114:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 120:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 125:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 129:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 132:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 140:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****  */
 141:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** void
 142:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** {
 144:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 153:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 156:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 159:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 164:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 166:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #else
 167:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	{
 172:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		{
 176:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		}
 180:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	}
 182:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	else
 183:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
 186:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** }
 187:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 188:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /**
 189:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 191:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 193:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 196:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 198:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 202:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   
 207:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 211:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****  
 214:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 222:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****  */
 223:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** void
 224:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** {
 226:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 235:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 238:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 241:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 246:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 306               		.loc 2 246 0
 307 006c 80EA      		ldi r24,lo8(-96)
 308 006e 8A95      		1: dec r24
 309 0070 01F4      		brne 1b
 310               	.LBE48:
 311               	.LBE47:
 312               	.LBB49:
 313               	.LBB44:
 161:matrix.c      ****     return (PINA&(1<<4) ? 0 : (1<<0)) |
 314               		.loc 1 161 0
 315 0072 80B1      		in r24,0
 316 0074 8295      		swap r24
 317 0076 8F70      		andi r24,lo8(15)
 318 0078 8C27      		eor r24,r28
 319 007a 80FB      		bst r24,0
 320 007c AA24      		clr r10
 321 007e A0F8      		bld r10,0
 322 0080 B12C      		mov r11,__zero_reg__
 162:matrix.c      ****            (PINA&(1<<5) ? 0 : (1<<1)) |
 323               		.loc 1 162 0
 324 0082 059B      		sbis 0,5
 325 0084 00C0      		rjmp .L45
 326 0086 20E0      		ldi r18,0
 327 0088 30E0      		ldi r19,0
 328 008a 00C0      		rjmp .L18
 329               	.L45:
 330 008c 22E0      		ldi r18,lo8(2)
 331 008e 30E0      		ldi r19,0
 332               	.L18:
 161:matrix.c      ****     return (PINA&(1<<4) ? 0 : (1<<0)) |
 333               		.loc 1 161 0
 334 0090 2A29      		or r18,r10
 335 0092 3B29      		or r19,r11
 163:matrix.c      ****            (PINA&(1<<6) ? 0 : (1<<2)) |
 336               		.loc 1 163 0
 337 0094 069B      		sbis 0,6
 338 0096 00C0      		rjmp .L46
 339 0098 80E0      		ldi r24,0
 340 009a 90E0      		ldi r25,0
 341 009c 00C0      		rjmp .L19
 342               	.L46:
 343 009e 84E0      		ldi r24,lo8(4)
 344 00a0 90E0      		ldi r25,0
 345               	.L19:
 162:matrix.c      ****            (PINA&(1<<5) ? 0 : (1<<1)) |
 346               		.loc 1 162 0
 347 00a2 282B      		or r18,r24
 348 00a4 392B      		or r19,r25
 164:matrix.c      ****            (PINA&(1<<7) ? 0 : (1<<3)) |
 349               		.loc 1 164 0
 350 00a6 80B1      		in r24,0
 351 00a8 9927      		clr r25
 352 00aa 87FD      		sbrc r24,7
 353 00ac 9095      		com r25
 354 00ae 8095      		com r24
 355 00b0 9095      		com r25
 356 00b2 8827      		clr r24
 357 00b4 990F      		lsl r25
 358 00b6 881F      		rol r24
 359 00b8 9927      		clr r25
 360 00ba 73E0      		ldi r23,3
 361               		1:
 362 00bc 880F      		lsl r24
 363 00be 991F      		rol r25
 364 00c0 7A95      		dec r23
 365 00c2 01F4      		brne 1b
 163:matrix.c      ****            (PINA&(1<<6) ? 0 : (1<<2)) |
 366               		.loc 1 163 0
 367 00c4 282B      		or r18,r24
 368 00c6 392B      		or r19,r25
 165:matrix.c      ****            (PINC&(1<<7) ? 0 : (1<<4)) |
 369               		.loc 1 165 0
 370 00c8 86B1      		in r24,0x6
 371 00ca 9927      		clr r25
 372 00cc 87FD      		sbrc r24,7
 373 00ce 9095      		com r25
 374 00d0 8095      		com r24
 375 00d2 9095      		com r25
 376 00d4 8827      		clr r24
 377 00d6 990F      		lsl r25
 378 00d8 881F      		rol r24
 379 00da 9927      		clr r25
 380 00dc F4E0      		ldi r31,4
 381               		1:
 382 00de 880F      		lsl r24
 383 00e0 991F      		rol r25
 384 00e2 FA95      		dec r31
 385 00e4 01F4      		brne 1b
 164:matrix.c      ****            (PINA&(1<<7) ? 0 : (1<<3)) |
 386               		.loc 1 164 0
 387 00e6 282B      		or r18,r24
 388 00e8 392B      		or r19,r25
 166:matrix.c      ****            (PINC&(1<<6) ? 0 : (1<<5)) |
 389               		.loc 1 166 0
 390 00ea 369B      		sbis 0x6,6
 391 00ec 00C0      		rjmp .L49
 392 00ee 80E0      		ldi r24,0
 393 00f0 90E0      		ldi r25,0
 394 00f2 00C0      		rjmp .L22
 395               	.L49:
 396 00f4 80E2      		ldi r24,lo8(32)
 397 00f6 90E0      		ldi r25,0
 398               	.L22:
 165:matrix.c      ****            (PINC&(1<<7) ? 0 : (1<<4)) |
 399               		.loc 1 165 0
 400 00f8 282B      		or r18,r24
 401 00fa 392B      		or r19,r25
 167:matrix.c      ****            (PINC&(1<<5) ? 0 : (1<<6)) |
 402               		.loc 1 167 0
 403 00fc 359B      		sbis 0x6,5
 404 00fe 00C0      		rjmp .L50
 405 0100 80E0      		ldi r24,0
 406 0102 90E0      		ldi r25,0
 407 0104 00C0      		rjmp .L23
 408               	.L50:
 409 0106 80E4      		ldi r24,lo8(64)
 410 0108 90E0      		ldi r25,0
 411               	.L23:
 166:matrix.c      ****            (PINC&(1<<6) ? 0 : (1<<5)) |
 412               		.loc 1 166 0
 413 010a 282B      		or r18,r24
 414 010c 392B      		or r19,r25
 168:matrix.c      ****            (PINC&(1<<4) ? 0 : (1<<7)) |
 415               		.loc 1 168 0
 416 010e 349B      		sbis 0x6,4
 417 0110 00C0      		rjmp .L51
 418 0112 60E0      		ldi r22,0
 419 0114 70E0      		ldi r23,0
 420 0116 00C0      		rjmp .L24
 421               	.L51:
 422 0118 60E8      		ldi r22,lo8(-128)
 423 011a 70E0      		ldi r23,0
 424               	.L24:
 167:matrix.c      ****            (PINC&(1<<5) ? 0 : (1<<6)) |
 425               		.loc 1 167 0
 426 011c 262B      		or r18,r22
 427 011e 372B      		or r19,r23
 169:matrix.c      ****            (PINC&(1<<3) ? 0 : (1<<8)) |
 428               		.loc 1 169 0
 429 0120 339B      		sbis 0x6,3
 430 0122 00C0      		rjmp .L52
 431 0124 40E0      		ldi r20,0
 432 0126 50E0      		ldi r21,0
 433 0128 00C0      		rjmp .L25
 434               	.L52:
 435 012a 40E0      		ldi r20,0
 436 012c 51E0      		ldi r21,lo8(1)
 437               	.L25:
 168:matrix.c      ****            (PINC&(1<<4) ? 0 : (1<<7)) |
 438               		.loc 1 168 0
 439 012e 242B      		or r18,r20
 440 0130 352B      		or r19,r21
 170:matrix.c      ****            (PINC&(1<<2) ? 0 : (1<<9)) |
 441               		.loc 1 170 0
 442 0132 329B      		sbis 0x6,2
 443 0134 00C0      		rjmp .L53
 444 0136 80E0      		ldi r24,0
 445 0138 90E0      		ldi r25,0
 446 013a 00C0      		rjmp .L26
 447               	.L53:
 448 013c 80E0      		ldi r24,0
 449 013e 92E0      		ldi r25,lo8(2)
 450               	.L26:
 169:matrix.c      ****            (PINC&(1<<3) ? 0 : (1<<8)) |
 451               		.loc 1 169 0
 452 0140 282B      		or r18,r24
 453 0142 392B      		or r19,r25
 171:matrix.c      ****            (PINC&(1<<1) ? 0 : (1<<10)) |
 454               		.loc 1 171 0
 455 0144 319B      		sbis 0x6,1
 456 0146 00C0      		rjmp .L54
 457 0148 60E0      		ldi r22,0
 458 014a 70E0      		ldi r23,0
 459 014c 00C0      		rjmp .L27
 460               	.L54:
 461 014e 60E0      		ldi r22,0
 462 0150 74E0      		ldi r23,lo8(4)
 463               	.L27:
 170:matrix.c      ****            (PINC&(1<<2) ? 0 : (1<<9)) |
 464               		.loc 1 170 0
 465 0152 262B      		or r18,r22
 466 0154 372B      		or r19,r23
 172:matrix.c      ****            (PINC&(1<<0) ? 0 : (1<<11)) |
 467               		.loc 1 172 0
 468 0156 309B      		sbis 0x6,0
 469 0158 00C0      		rjmp .L55
 470 015a 40E0      		ldi r20,0
 471 015c 50E0      		ldi r21,0
 472 015e 00C0      		rjmp .L28
 473               	.L55:
 474 0160 40E0      		ldi r20,0
 475 0162 58E0      		ldi r21,lo8(8)
 476               	.L28:
 171:matrix.c      ****            (PINC&(1<<1) ? 0 : (1<<10)) |
 477               		.loc 1 171 0
 478 0164 242B      		or r18,r20
 479 0166 352B      		or r19,r21
 173:matrix.c      ****            (PINE&(1<<1) ? 0 : (1<<12)) |
 480               		.loc 1 173 0
 481 0168 619B      		sbis 0xc,1
 482 016a 00C0      		rjmp .L56
 483 016c 80E0      		ldi r24,0
 484 016e 90E0      		ldi r25,0
 485 0170 00C0      		rjmp .L29
 486               	.L56:
 487 0172 80E0      		ldi r24,0
 488 0174 90E1      		ldi r25,lo8(16)
 489               	.L29:
 172:matrix.c      ****            (PINC&(1<<0) ? 0 : (1<<11)) |
 490               		.loc 1 172 0
 491 0176 282B      		or r18,r24
 492 0178 392B      		or r19,r25
 174:matrix.c      ****            (PINE&(1<<0) ? 0 : (1<<13)) |
 493               		.loc 1 174 0
 494 017a 609B      		sbis 0xc,0
 495 017c 00C0      		rjmp .L57
 496 017e 80E0      		ldi r24,0
 497 0180 90E0      		ldi r25,0
 498 0182 00C0      		rjmp .L30
 499               	.L57:
 500 0184 80E0      		ldi r24,0
 501 0186 90E2      		ldi r25,lo8(32)
 502               	.L30:
 173:matrix.c      ****            (PINE&(1<<1) ? 0 : (1<<12)) |
 503               		.loc 1 173 0
 504 0188 282B      		or r18,r24
 505 018a 392B      		or r19,r25
 175:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<<14)) |
 506               		.loc 1 175 0
 507 018c 89B1      		in r24,0x9
 508 018e 9927      		clr r25
 509 0190 87FD      		sbrc r24,7
 510 0192 9095      		com r25
 511 0194 8095      		com r24
 512 0196 9095      		com r25
 513 0198 8827      		clr r24
 514 019a 990F      		lsl r25
 515 019c 881F      		rol r24
 516 019e 9927      		clr r25
 517 01a0 90E4      		ldi r25,0x40
 518 01a2 899F      		mul r24,r25
 519 01a4 902D      		mov r25,r0
 520 01a6 8827      		clr r24
 521 01a8 1124      		clr __zero_reg__
 174:matrix.c      ****            (PINE&(1<<0) ? 0 : (1<<13)) |
 522               		.loc 1 174 0
 523 01aa 282B      		or r18,r24
 524 01ac 392B      		or r19,r25
 176:matrix.c      ****            (PIND&(1<<5) ? 0 : (1<<15));
 525               		.loc 1 176 0
 526 01ae 4D9B      		sbis 0x9,5
 527 01b0 00C0      		rjmp .L59
 528 01b2 80E0      		ldi r24,0
 529 01b4 90E0      		ldi r25,0
 530 01b6 00C0      		rjmp .L32
 531               	.L59:
 532 01b8 80E0      		ldi r24,0
 533 01ba 90E8      		ldi r25,lo8(-128)
 534               	.L32:
 175:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<<14)) |
 535               		.loc 1 175 0
 536 01bc 282B      		or r18,r24
 537 01be 392B      		or r19,r25
 538               	.LBE44:
 539               	.LBE49:
  81:matrix.c      ****         if (matrix_debouncing[i] != cols) {
 540               		.loc 1 81 0
 541 01c0 D701      		movw r26,r14
 542 01c2 8D91      		ld r24,X+
 543 01c4 9C91      		ld r25,X
 544 01c6 1197      		sbiw r26,1
 545 01c8 8217      		cp r24,r18
 546 01ca 9307      		cpc r25,r19
 547 01cc 01F0      		breq .L33
  82:matrix.c      ****             matrix_debouncing[i] = cols;
 548               		.loc 1 82 0
 549 01ce 2D93      		st X+,r18
 550 01d0 3C93      		st X,r19
  83:matrix.c      ****             if (debouncing) {
 551               		.loc 1 83 0
 552 01d2 8091 0000 		lds r24,debouncing
 553 01d6 8823      		tst r24
 554 01d8 01F0      		breq .L35
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 555               		.loc 1 84 0
 556 01da 8091 0000 		lds r24,debug_config
 557 01de 80FF      		sbrs r24,0
 558 01e0 00C0      		rjmp .L36
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 559               		.loc 1 84 0 is_stmt 0 discriminator 1
 560 01e2 80E0      		ldi r24,lo8(__c.1778)
 561 01e4 90E0      		ldi r25,hi8(__c.1778)
 562 01e6 0E94 0000 		call xputs
 563               	.LVL6:
 564               	.L36:
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 565               		.loc 1 84 0 discriminator 2
 566 01ea 8091 0000 		lds r24,debug_config
 567 01ee 80FF      		sbrs r24,0
 568 01f0 00C0      		rjmp .L37
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 569               		.loc 1 84 0 discriminator 1
 570 01f2 8091 0000 		lds r24,debouncing
 571 01f6 1F92      		push __zero_reg__
 572               	.LCFI9:
 573               		.cfi_def_cfa_offset 12
 574 01f8 8F93      		push r24
 575               	.LCFI10:
 576               		.cfi_def_cfa_offset 13
 577 01fa 80E0      		ldi r24,lo8(__c.1780)
 578 01fc 90E0      		ldi r25,hi8(__c.1780)
 579 01fe 9F93      		push r25
 580               	.LCFI11:
 581               		.cfi_def_cfa_offset 14
 582 0200 8F93      		push r24
 583               	.LCFI12:
 584               		.cfi_def_cfa_offset 15
 585 0202 0E94 0000 		call __xprintf
 586               	.LVL7:
 587 0206 0F90      		pop __tmp_reg__
 588 0208 0F90      		pop __tmp_reg__
 589 020a 0F90      		pop __tmp_reg__
 590 020c 0F90      		pop __tmp_reg__
 591               	.LCFI13:
 592               		.cfi_def_cfa_offset 11
 593               	.L37:
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 594               		.loc 1 84 0 discriminator 2
 595 020e 8091 0000 		lds r24,debug_config
 596 0212 80FF      		sbrs r24,0
 597 0214 00C0      		rjmp .L35
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 598               		.loc 1 84 0 discriminator 1
 599 0216 80E0      		ldi r24,lo8(__c.1782)
 600 0218 90E0      		ldi r25,hi8(__c.1782)
 601 021a 0E94 0000 		call xputs
 602               	.LVL8:
 603               	.L35:
  86:matrix.c      ****             debouncing = DEBOUNCE;
 604               		.loc 1 86 0 is_stmt 1
 605 021e D093 0000 		sts debouncing,r29
 606               	.L33:
  88:matrix.c      ****         unselect_rows();
 607               		.loc 1 88 0
 608 0222 0E94 0000 		call unselect_rows
 609               	.LVL9:
 610               	.LBE41:
  77:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 611               		.loc 1 77 0
 612 0226 1F5F      		subi r17,lo8(-(1))
 613               	.LVL10:
 614 0228 B2E0      		ldi r27,2
 615 022a EB0E      		add r14,r27
 616 022c F11C      		adc r15,__zero_reg__
 617 022e 1830      		cpi r17,lo8(8)
 618 0230 01F0      		breq .+2
 619 0232 00C0      		rjmp .L39
 620               	.LBE40:
  91:matrix.c      ****     if (debouncing) {
 621               		.loc 1 91 0
 622 0234 8091 0000 		lds r24,debouncing
 623 0238 8823      		tst r24
 624 023a 01F0      		breq .L41
  92:matrix.c      ****         if (--debouncing) {
 625               		.loc 1 92 0
 626 023c 8150      		subi r24,lo8(-(-1))
 627 023e 8093 0000 		sts debouncing,r24
 628 0242 8823      		tst r24
 629 0244 01F0      		breq .L42
 630               	.LVL11:
 631               	.LBB50:
 632               	.LBB51:
 164:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 633               		.loc 2 164 0
 634 0246 EFE9      		ldi r30,lo8(3999)
 635 0248 FFE0      		ldi r31,hi8(3999)
 636 024a 3197      		1: sbiw r30,1
 637 024c 01F4      		brne 1b
 638 024e 00C0      		rjmp .
 639 0250 0000      		nop
 640 0252 00C0      		rjmp .L41
 641               	.LVL12:
 642               	.L42:
 643 0254 E0E0      		ldi r30,lo8(matrix)
 644 0256 F0E0      		ldi r31,hi8(matrix)
 645               	.L43:
 646               	.LBE51:
 647               	.LBE50:
 648               	.LBB52:
  96:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 649               		.loc 1 96 0 discriminator 2
 650 0258 D601      		movw r26,r12
 651 025a 8D91      		ld r24,X+
 652 025c 9D91      		ld r25,X+
 653 025e 6D01      		movw r12,r26
 654 0260 8193      		st Z+,r24
 655 0262 9193      		st Z+,r25
 656               	.LVL13:
  95:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 657               		.loc 1 95 0 discriminator 2
 658 0264 B0E0      		ldi r27,lo8(matrix_debouncing+16)
 659 0266 CB16      		cp r12,r27
 660 0268 B0E0      		ldi r27,hi8(matrix_debouncing+16)
 661 026a DB06      		cpc r13,r27
 662 026c 01F4      		brne .L43
 663               	.L41:
 664               	.LBE52:
 102:matrix.c      **** }
 665               		.loc 1 102 0
 666 026e 81E0      		ldi r24,lo8(1)
 667               	/* epilogue start */
 668 0270 DF91      		pop r29
 669 0272 CF91      		pop r28
 670 0274 1F91      		pop r17
 671               	.LVL14:
 672 0276 FF90      		pop r15
 673 0278 EF90      		pop r14
 674 027a DF90      		pop r13
 675 027c CF90      		pop r12
 676 027e BF90      		pop r11
 677 0280 AF90      		pop r10
 678 0282 0895      		ret
 679               		.cfi_endproc
 680               	.LFE10:
 682               		.section	.text.matrix_is_modified,"ax",@progbits
 683               	.global	matrix_is_modified
 685               	matrix_is_modified:
 686               	.LFB11:
 105:matrix.c      **** {
 687               		.loc 1 105 0
 688               		.cfi_startproc
 689               	/* prologue: function */
 690               	/* frame size = 0 */
 691               	/* stack size = 0 */
 692               	.L__stack_usage = 0
 106:matrix.c      ****     if (debouncing) return false;
 693               		.loc 1 106 0
 694 0000 81E0      		ldi r24,lo8(1)
 695 0002 9091 0000 		lds r25,debouncing
 696 0006 9111      		cpse r25,__zero_reg__
 697 0008 80E0      		ldi r24,0
 698               	.L72:
 108:matrix.c      **** }
 699               		.loc 1 108 0
 700 000a 0895      		ret
 701               		.cfi_endproc
 702               	.LFE11:
 704               		.section	.text.matrix_is_on,"ax",@progbits
 705               	.global	matrix_is_on
 707               	matrix_is_on:
 708               	.LFB12:
 112:matrix.c      **** {
 709               		.loc 1 112 0
 710               		.cfi_startproc
 711               	.LVL15:
 712               	/* prologue: function */
 713               	/* frame size = 0 */
 714               	/* stack size = 0 */
 715               	.L__stack_usage = 0
 113:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 716               		.loc 1 113 0
 717 0000 21E0      		ldi r18,lo8(1)
 718 0002 30E0      		ldi r19,0
 719 0004 00C0      		rjmp 2f
 720               		1:
 721 0006 220F      		lsl r18
 722 0008 331F      		rol r19
 723               		2:
 724 000a 6A95      		dec r22
 725 000c 02F4      		brpl 1b
 726 000e E82F      		mov r30,r24
 727 0010 F0E0      		ldi r31,0
 728 0012 EE0F      		lsl r30
 729 0014 FF1F      		rol r31
 730 0016 E050      		subi r30,lo8(-(matrix))
 731 0018 F040      		sbci r31,hi8(-(matrix))
 732 001a 8081      		ld r24,Z
 733 001c 9181      		ldd r25,Z+1
 734               	.LVL16:
 735 001e 2823      		and r18,r24
 736 0020 3923      		and r19,r25
 737 0022 81E0      		ldi r24,lo8(1)
 738 0024 232B      		or r18,r19
 739 0026 01F4      		brne .L77
 740 0028 80E0      		ldi r24,0
 741               	.L77:
 114:matrix.c      **** }
 742               		.loc 1 114 0
 743 002a 0895      		ret
 744               		.cfi_endproc
 745               	.LFE12:
 747               		.section	.text.matrix_get_row,"ax",@progbits
 748               	.global	matrix_get_row
 750               	matrix_get_row:
 751               	.LFB13:
 118:matrix.c      **** {
 752               		.loc 1 118 0
 753               		.cfi_startproc
 754               	.LVL17:
 755               	/* prologue: function */
 756               	/* frame size = 0 */
 757               	/* stack size = 0 */
 758               	.L__stack_usage = 0
 119:matrix.c      ****     return matrix[row];
 759               		.loc 1 119 0
 760 0000 E82F      		mov r30,r24
 761 0002 F0E0      		ldi r31,0
 762 0004 EE0F      		lsl r30
 763 0006 FF1F      		rol r31
 764               	.LVL18:
 765 0008 E050      		subi r30,lo8(-(matrix))
 766 000a F040      		sbci r31,hi8(-(matrix))
 120:matrix.c      **** }
 767               		.loc 1 120 0
 768 000c 8081      		ld r24,Z
 769 000e 9181      		ldd r25,Z+1
 770 0010 0895      		ret
 771               		.cfi_endproc
 772               	.LFE13:
 774               		.section	.text.matrix_print,"ax",@progbits
 775               	.global	matrix_print
 777               	matrix_print:
 778               	.LFB14:
 123:matrix.c      **** {
 779               		.loc 1 123 0
 780               		.cfi_startproc
 781 0000 8F92      		push r8
 782               	.LCFI14:
 783               		.cfi_def_cfa_offset 3
 784               		.cfi_offset 8, -2
 785 0002 9F92      		push r9
 786               	.LCFI15:
 787               		.cfi_def_cfa_offset 4
 788               		.cfi_offset 9, -3
 789 0004 AF92      		push r10
 790               	.LCFI16:
 791               		.cfi_def_cfa_offset 5
 792               		.cfi_offset 10, -4
 793 0006 BF92      		push r11
 794               	.LCFI17:
 795               		.cfi_def_cfa_offset 6
 796               		.cfi_offset 11, -5
 797 0008 CF92      		push r12
 798               	.LCFI18:
 799               		.cfi_def_cfa_offset 7
 800               		.cfi_offset 12, -6
 801 000a DF92      		push r13
 802               	.LCFI19:
 803               		.cfi_def_cfa_offset 8
 804               		.cfi_offset 13, -7
 805 000c EF92      		push r14
 806               	.LCFI20:
 807               		.cfi_def_cfa_offset 9
 808               		.cfi_offset 14, -8
 809 000e FF92      		push r15
 810               	.LCFI21:
 811               		.cfi_def_cfa_offset 10
 812               		.cfi_offset 15, -9
 813               	/* prologue: function */
 814               	/* frame size = 0 */
 815               	/* stack size = 8 */
 816               	.L__stack_usage = 8
 124:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 817               		.loc 1 124 0
 818 0010 80E0      		ldi r24,lo8(__c.1804)
 819 0012 90E0      		ldi r25,hi8(__c.1804)
 820 0014 0E94 0000 		call xputs
 821 0018 90E0      		ldi r25,lo8(matrix)
 822 001a A92E      		mov r10,r25
 823 001c 90E0      		ldi r25,hi8(matrix)
 824 001e B92E      		mov r11,r25
 825 0020 E12C      		mov r14,__zero_reg__
 826 0022 F12C      		mov r15,__zero_reg__
 827               	.LBB53:
 126:matrix.c      ****         phex(row); print(": ");
 828               		.loc 1 126 0
 829 0024 20E0      		ldi r18,lo8(__c.1807)
 830 0026 822E      		mov r8,r18
 831 0028 20E0      		ldi r18,hi8(__c.1807)
 832 002a 922E      		mov r9,r18
 127:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 833               		.loc 1 127 0
 834 002c 30E0      		ldi r19,lo8(__c.1811)
 835 002e C32E      		mov r12,r19
 836 0030 30E0      		ldi r19,hi8(__c.1811)
 837 0032 D32E      		mov r13,r19
 838               	.L80:
 126:matrix.c      ****         phex(row); print(": ");
 839               		.loc 1 126 0 discriminator 2
 840 0034 FF92      		push r15
 841               	.LCFI22:
 842               		.cfi_def_cfa_offset 11
 843 0036 EF92      		push r14
 844               	.LCFI23:
 845               		.cfi_def_cfa_offset 12
 846 0038 9F92      		push r9
 847               	.LCFI24:
 848               		.cfi_def_cfa_offset 13
 849 003a 8F92      		push r8
 850               	.LCFI25:
 851               		.cfi_def_cfa_offset 14
 852 003c 0E94 0000 		call __xprintf
 853 0040 80E0      		ldi r24,lo8(__c.1809)
 854 0042 90E0      		ldi r25,hi8(__c.1809)
 855 0044 0E94 0000 		call xputs
 127:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 856               		.loc 1 127 0 discriminator 2
 857 0048 F501      		movw r30,r10
 858 004a 8191      		ld r24,Z+
 859 004c 9191      		ld r25,Z+
 860 004e 5F01      		movw r10,r30
 861 0050 0E94 0000 		call bitrev16
 862 0054 9F93      		push r25
 863               	.LCFI26:
 864               		.cfi_def_cfa_offset 15
 865 0056 8F93      		push r24
 866               	.LCFI27:
 867               		.cfi_def_cfa_offset 16
 868 0058 DF92      		push r13
 869               	.LCFI28:
 870               		.cfi_def_cfa_offset 17
 871 005a CF92      		push r12
 872               	.LCFI29:
 873               		.cfi_def_cfa_offset 18
 874 005c 0E94 0000 		call __xprintf
 128:matrix.c      ****         print("\n");
 875               		.loc 1 128 0 discriminator 2
 876 0060 80E0      		ldi r24,lo8(__c.1813)
 877 0062 90E0      		ldi r25,hi8(__c.1813)
 878 0064 0E94 0000 		call xputs
 879 0068 FFEF      		ldi r31,-1
 880 006a EF1A      		sub r14,r31
 881 006c FF0A      		sbc r15,r31
 125:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 882               		.loc 1 125 0 discriminator 2
 883 006e 8DB7      		in r24,__SP_L__
 884 0070 9EB7      		in r25,__SP_H__
 885 0072 0896      		adiw r24,8
 886 0074 0FB6      		in __tmp_reg__,__SREG__
 887 0076 F894      		cli
 888 0078 9EBF      		out __SP_H__,r25
 889 007a 0FBE      		out __SREG__,__tmp_reg__
 890 007c 8DBF      		out __SP_L__,r24
 891               	.LCFI30:
 892               		.cfi_def_cfa_offset 10
 893 007e 98E0      		ldi r25,8
 894 0080 E916      		cp r14,r25
 895 0082 F104      		cpc r15,__zero_reg__
 896 0084 01F4      		brne .L80
 897               	/* epilogue start */
 898               	.LBE53:
 130:matrix.c      **** }
 899               		.loc 1 130 0
 900 0086 FF90      		pop r15
 901 0088 EF90      		pop r14
 902 008a DF90      		pop r13
 903 008c CF90      		pop r12
 904 008e BF90      		pop r11
 905 0090 AF90      		pop r10
 906 0092 9F90      		pop r9
 907 0094 8F90      		pop r8
 908 0096 0895      		ret
 909               		.cfi_endproc
 910               	.LFE14:
 912               		.section	.text.matrix_key_count,"ax",@progbits
 913               	.global	matrix_key_count
 915               	matrix_key_count:
 916               	.LFB15:
 133:matrix.c      **** {
 917               		.loc 1 133 0
 918               		.cfi_startproc
 919 0000 EF92      		push r14
 920               	.LCFI31:
 921               		.cfi_def_cfa_offset 3
 922               		.cfi_offset 14, -2
 923 0002 FF92      		push r15
 924               	.LCFI32:
 925               		.cfi_def_cfa_offset 4
 926               		.cfi_offset 15, -3
 927 0004 CF93      		push r28
 928               	.LCFI33:
 929               		.cfi_def_cfa_offset 5
 930               		.cfi_offset 28, -4
 931               	/* prologue: function */
 932               	/* frame size = 0 */
 933               	/* stack size = 3 */
 934               	.L__stack_usage = 3
 935               	.LVL19:
 936 0006 40E0      		ldi r20,lo8(matrix)
 937 0008 E42E      		mov r14,r20
 938 000a 40E0      		ldi r20,hi8(matrix)
 939 000c F42E      		mov r15,r20
 134:matrix.c      ****     uint8_t count = 0;
 940               		.loc 1 134 0
 941 000e C0E0      		ldi r28,0
 942               	.LVL20:
 943               	.L83:
 944               	.LBB54:
 136:matrix.c      ****         count += bitpop16(matrix[i]);
 945               		.loc 1 136 0 discriminator 2
 946 0010 F701      		movw r30,r14
 947 0012 8191      		ld r24,Z+
 948 0014 9191      		ld r25,Z+
 949 0016 7F01      		movw r14,r30
 950 0018 0E94 0000 		call bitpop16
 951               	.LVL21:
 952 001c C80F      		add r28,r24
 953               	.LVL22:
 135:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 954               		.loc 1 135 0 discriminator 2
 955 001e F0E0      		ldi r31,lo8(matrix+16)
 956 0020 EF16      		cp r14,r31
 957 0022 F0E0      		ldi r31,hi8(matrix+16)
 958 0024 FF06      		cpc r15,r31
 959 0026 01F4      		brne .L83
 960               	.LBE54:
 139:matrix.c      **** }
 961               		.loc 1 139 0
 962 0028 8C2F      		mov r24,r28
 963               	/* epilogue start */
 964 002a CF91      		pop r28
 965               	.LVL23:
 966 002c FF90      		pop r15
 967 002e EF90      		pop r14
 968 0030 0895      		ret
 969               		.cfi_endproc
 970               	.LFE15:
 972               		.section	.bss.matrix,"aw",@nobits
 975               	matrix:
 976 0000 0000 0000 		.zero	16
 976      0000 0000 
 976      0000 0000 
 976      0000 0000 
 977               		.section	.bss.matrix_debouncing,"aw",@nobits
 980               	matrix_debouncing:
 981 0000 0000 0000 		.zero	16
 981      0000 0000 
 981      0000 0000 
 981      0000 0000 
 982               		.section	.data.debouncing,"aw",@progbits
 985               	debouncing:
 986 0000 05        		.byte	5
 987               		.section	.progmem.data.__c.1778,"a",@progbits
 990               	__c.1778:
 991 0000 626F 756E 		.string	"bounce!: "
 991      6365 213A 
 991      2000 
 992               		.section	.progmem.data.__c.1780,"a",@progbits
 995               	__c.1780:
 996 0000 2530 3258 		.string	"%02X"
 996      00
 997               		.section	.progmem.data.__c.1782,"a",@progbits
 1000               	__c.1782:
 1001 0000 0A00      		.string	"\n"
 1002               		.section	.progmem.data.__c.1804,"a",@progbits
 1005               	__c.1804:
 1006 0000 0A72 2F63 		.string	"\nr/c 0123456789ABCDEF\n"
 1006      2030 3132 
 1006      3334 3536 
 1006      3738 3941 
 1006      4243 4445 
 1007               		.section	.progmem.data.__c.1807,"a",@progbits
 1010               	__c.1807:
 1011 0000 2530 3258 		.string	"%02X"
 1011      00
 1012               		.section	.progmem.data.__c.1809,"a",@progbits
 1015               	__c.1809:
 1016 0000 3A20 00   		.string	": "
 1017               		.section	.progmem.data.__c.1811,"a",@progbits
 1020               	__c.1811:
 1021 0000 2530 3136 		.string	"%016b"
 1021      6200 
 1022               		.section	.progmem.data.__c.1813,"a",@progbits
 1025               	__c.1813:
 1026 0000 0A00      		.string	"\n"
 1027               		.text
 1028               	.Letext0:
 1029               		.file 3 "/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/stdint.h"
 1030               		.file 4 "../../../../tmk_core/common/debug.h"
 1031               		.file 5 "../../../../tmk_core/common/matrix.h"
 1032               		.file 6 "../../../../tmk_core/common/avr/xprintf.h"
 1033               		.file 7 "../../../../tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccKcKL8N.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccKcKL8N.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccKcKL8N.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccKcKL8N.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccKcKL8N.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccKcKL8N.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccKcKL8N.s:13     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/ccKcKL8N.s:53     .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/ccKcKL8N.s:70     .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/ccKcKL8N.s:87     .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccKcKL8N.s:975    .bss.matrix:0000000000000000 matrix
     /tmp/ccKcKL8N.s:980    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccKcKL8N.s:170    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccKcKL8N.s:985    .data.debouncing:0000000000000000 debouncing
     /tmp/ccKcKL8N.s:990    .progmem.data.__c.1778:0000000000000000 __c.1778
     /tmp/ccKcKL8N.s:995    .progmem.data.__c.1780:0000000000000000 __c.1780
     /tmp/ccKcKL8N.s:1000   .progmem.data.__c.1782:0000000000000000 __c.1782
     /tmp/ccKcKL8N.s:685    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/ccKcKL8N.s:707    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/ccKcKL8N.s:750    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/ccKcKL8N.s:777    .text.matrix_print:0000000000000000 matrix_print
     /tmp/ccKcKL8N.s:1005   .progmem.data.__c.1804:0000000000000000 __c.1804
     /tmp/ccKcKL8N.s:1010   .progmem.data.__c.1807:0000000000000000 __c.1807
     /tmp/ccKcKL8N.s:1020   .progmem.data.__c.1811:0000000000000000 __c.1811
     /tmp/ccKcKL8N.s:1015   .progmem.data.__c.1809:0000000000000000 __c.1809
     /tmp/ccKcKL8N.s:1025   .progmem.data.__c.1813:0000000000000000 __c.1813
     /tmp/ccKcKL8N.s:915    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
debug_config
xputs
__xprintf
bitrev16
bitpop16
__do_copy_data
__do_clear_bss
