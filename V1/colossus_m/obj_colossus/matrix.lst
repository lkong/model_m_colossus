   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.unselect_rows,"ax",@progbits
  13               	unselect_rows:
  14               	.LFB17:
  15               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "print.h"
  26:matrix.c      **** #include "debug.h"
  27:matrix.c      **** #include "util.h"
  28:matrix.c      **** #include "matrix.h"
  29:matrix.c      **** 
  30:matrix.c      **** 
  31:matrix.c      **** #ifndef DEBOUNCE
  32:matrix.c      **** #define DEBOUNCE	5
  33:matrix.c      **** #endif
  34:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  35:matrix.c      **** 
  36:matrix.c      **** /* matrix state(1:on, 0:off) */
  37:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  38:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  39:matrix.c      **** 
  40:matrix.c      **** static matrix_row_t read_cols(void);
  41:matrix.c      **** static void init_cols(void);
  42:matrix.c      **** static void unselect_rows(void);
  43:matrix.c      **** static void select_row(uint8_t row);
  44:matrix.c      **** 
  45:matrix.c      **** 
  46:matrix.c      **** inline
  47:matrix.c      **** uint8_t matrix_rows(void)
  48:matrix.c      **** {
  49:matrix.c      ****     return MATRIX_ROWS;
  50:matrix.c      **** }
  51:matrix.c      **** 
  52:matrix.c      **** inline
  53:matrix.c      **** uint8_t matrix_cols(void)
  54:matrix.c      **** {
  55:matrix.c      ****     return MATRIX_COLS;
  56:matrix.c      **** }
  57:matrix.c      **** 
  58:matrix.c      **** void matrix_init(void)
  59:matrix.c      **** {
  60:matrix.c      ****     // JTAG disable for PORT F. write JTD bit twice within four cycles.
  61:matrix.c      ****     MCUCR |= (1<<JTD);
  62:matrix.c      ****     MCUCR |= (1<<JTD);
  63:matrix.c      **** 
  64:matrix.c      ****     // initialize row and col
  65:matrix.c      ****     unselect_rows();
  66:matrix.c      ****     init_cols();
  67:matrix.c      **** 
  68:matrix.c      ****     // initialize matrix state: all keys off
  69:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  70:matrix.c      ****         matrix[i] = 0;
  71:matrix.c      ****         matrix_debouncing[i] = 0;
  72:matrix.c      ****     }
  73:matrix.c      **** }
  74:matrix.c      **** 
  75:matrix.c      **** uint8_t matrix_scan(void)
  76:matrix.c      **** {
  77:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  78:matrix.c      ****         select_row(i);
  79:matrix.c      ****         _delay_us(30);  // without this wait read unstable value.
  80:matrix.c      ****         matrix_row_t cols = read_cols();
  81:matrix.c      ****         if (matrix_debouncing[i] != cols) {
  82:matrix.c      ****             matrix_debouncing[i] = cols;
  83:matrix.c      ****             if (debouncing) {
  84:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
  85:matrix.c      ****             }
  86:matrix.c      ****             debouncing = DEBOUNCE;
  87:matrix.c      ****         }
  88:matrix.c      ****         unselect_rows();
  89:matrix.c      ****     }
  90:matrix.c      **** 
  91:matrix.c      ****     if (debouncing) {
  92:matrix.c      ****         if (--debouncing) {
  93:matrix.c      ****             _delay_ms(1);
  94:matrix.c      ****         } else {
  95:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  96:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
  97:matrix.c      ****             }
  98:matrix.c      ****         }
  99:matrix.c      ****     }
 100:matrix.c      **** 
 101:matrix.c      ****     return 1;
 102:matrix.c      **** }
 103:matrix.c      **** 
 104:matrix.c      **** bool matrix_is_modified(void)
 105:matrix.c      **** {
 106:matrix.c      ****     if (debouncing) return false;
 107:matrix.c      ****     return true;
 108:matrix.c      **** }
 109:matrix.c      **** 
 110:matrix.c      **** inline
 111:matrix.c      **** bool matrix_is_on(uint8_t row, uint8_t col)
 112:matrix.c      **** {
 113:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 114:matrix.c      **** }
 115:matrix.c      **** 
 116:matrix.c      **** inline
 117:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
 118:matrix.c      **** {
 119:matrix.c      ****     return matrix[row];
 120:matrix.c      **** }
 121:matrix.c      **** 
 122:matrix.c      **** void matrix_print(void)
 123:matrix.c      **** {
 124:matrix.c      ****     print("\nr/c 0123456789ABCDEF\n");
 125:matrix.c      ****     for (uint8_t row = 0; row < MATRIX_ROWS; row++) {
 126:matrix.c      ****         phex(row); print(": ");
 127:matrix.c      ****         pbin_reverse16(matrix_get_row(row));
 128:matrix.c      ****         print("\n");
 129:matrix.c      ****     }
 130:matrix.c      **** }
 131:matrix.c      **** 
 132:matrix.c      **** uint8_t matrix_key_count(void)
 133:matrix.c      **** {
 134:matrix.c      ****     uint8_t count = 0;
 135:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 136:matrix.c      ****         count += bitpop16(matrix[i]);
 137:matrix.c      ****     }
 138:matrix.c      ****     return count;
 139:matrix.c      **** }
 140:matrix.c      **** 
 141:matrix.c      **** 
 142:matrix.c      ****  /* Column pin configuration
 143:matrix.c      ****  * col: 0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f
 144:matrix.c      ****  * pin: a4  a5  a6  a7  c7  c6  c5  c4  c3  c2  c1  c0  e1  e0  d7  d5	
 145:matrix.c      ****  */
 146:matrix.c      ****  static void  init_cols(void)
 147:matrix.c      **** {
 148:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 149:matrix.c      ****     DDRA  &= ~(1<<4 | 1<<5 | 1<<6 | 1<<7);
 150:matrix.c      ****     PORTA |=  (1<<4 | 1<<5 | 1<<6 | 1<<7);
 151:matrix.c      ****     DDRC  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 152:matrix.c      ****     PORTC |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 153:matrix.c      ****     DDRE  &= ~(1<<1 | 1<<0);
 154:matrix.c      ****     PORTE |=  (1<<1 | 1<<0);
 155:matrix.c      ****     DDRD  &= ~(1<<7 | 1<<5);
 156:matrix.c      ****     PORTD |=  (1<<7 | 1<<5);  
 157:matrix.c      **** }
 158:matrix.c      **** 
 159:matrix.c      **** static matrix_row_t read_cols(void)
 160:matrix.c      **** {
 161:matrix.c      ****     return (PINA&(1<<4) ? 0 : (1<<0)) |
 162:matrix.c      ****            (PINA&(1<<5) ? 0 : (1<<1)) |
 163:matrix.c      ****            (PINA&(1<<6) ? 0 : (1<<2)) |
 164:matrix.c      ****            (PINA&(1<<7) ? 0 : (1<<3)) |
 165:matrix.c      ****            (PINC&(1<<7) ? 0 : (1<<4)) |
 166:matrix.c      ****            (PINC&(1<<6) ? 0 : (1<<5)) |
 167:matrix.c      ****            (PINC&(1<<5) ? 0 : (1<<6)) |
 168:matrix.c      ****            (PINC&(1<<4) ? 0 : (1<<7)) |
 169:matrix.c      ****            (PINC&(1<<3) ? 0 : (1<<8)) |
 170:matrix.c      ****            (PINC&(1<<2) ? 0 : (1<<9)) |
 171:matrix.c      ****            (PINC&(1<<1) ? 0 : (1<<10)) |
 172:matrix.c      ****            (PINC&(1<<0) ? 0 : (1<<11)) |
 173:matrix.c      ****            (PINE&(1<<1) ? 0 : (1<<12)) |
 174:matrix.c      ****            (PINE&(1<<0) ? 0 : (1<<13)) |
 175:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<<14)) |
 176:matrix.c      ****            (PIND&(1<<5) ? 0 : (1<<15));
 177:matrix.c      **** }
 178:matrix.c      **** 
 179:matrix.c      **** /* row pin configuration
 180:matrix.c      ****  * row: 0   1   2   3   4   5   6   7   
 181:matrix.c      ****  * pin: b5  b6  b7  e4  e5  d0  d1  d4    
 182:matrix.c      ****  */
 183:matrix.c      **** 
 184:matrix.c      **** static void unselect_rows(void)
 185:matrix.c      **** {
  16               		.loc 1 185 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 186:matrix.c      ****     // Hi-Z(DDR:0, PORT:0) to unselect
 187:matrix.c      ****     DDRB  &= ~0b11100000;
  22               		.loc 1 187 0
  23 0000 84B1      		in r24,0x4
  24 0002 8F71      		andi r24,lo8(31)
  25 0004 84B9      		out 0x4,r24
 188:matrix.c      ****     PORTB &= ~0b11100000;
  26               		.loc 1 188 0
  27 0006 85B1      		in r24,0x5
  28 0008 8F71      		andi r24,lo8(31)
  29 000a 85B9      		out 0x5,r24
 189:matrix.c      ****     DDRE  &= ~0b00110000;
  30               		.loc 1 189 0
  31 000c 8DB1      		in r24,0xd
  32 000e 8F7C      		andi r24,lo8(-49)
  33 0010 8DB9      		out 0xd,r24
 190:matrix.c      ****     PORTE &= ~0b00110000;
  34               		.loc 1 190 0
  35 0012 8EB1      		in r24,0xe
  36 0014 8F7C      		andi r24,lo8(-49)
  37 0016 8EB9      		out 0xe,r24
 191:matrix.c      ****     DDRD  &= ~0b00010011;
  38               		.loc 1 191 0
  39 0018 8AB1      		in r24,0xa
  40 001a 8C7E      		andi r24,lo8(-20)
  41 001c 8AB9      		out 0xa,r24
 192:matrix.c      ****     PORTD &= ~0b00010011;
  42               		.loc 1 192 0
  43 001e 8BB1      		in r24,0xb
  44 0020 8C7E      		andi r24,lo8(-20)
  45 0022 8BB9      		out 0xb,r24
  46 0024 0895      		ret
  47               		.cfi_endproc
  48               	.LFE17:
  50               		.section	.text.matrix_rows,"ax",@progbits
  51               	.global	matrix_rows
  53               	matrix_rows:
  54               	.LFB6:
  48:matrix.c      **** {
  55               		.loc 1 48 0
  56               		.cfi_startproc
  57               	/* prologue: function */
  58               	/* frame size = 0 */
  59               	/* stack size = 0 */
  60               	.L__stack_usage = 0
  50:matrix.c      **** }
  61               		.loc 1 50 0
  62 0000 88E0      		ldi r24,lo8(8)
  63 0002 0895      		ret
  64               		.cfi_endproc
  65               	.LFE6:
  67               		.section	.text.matrix_cols,"ax",@progbits
  68               	.global	matrix_cols
  70               	matrix_cols:
  71               	.LFB7:
  54:matrix.c      **** {
  72               		.loc 1 54 0
  73               		.cfi_startproc
  74               	/* prologue: function */
  75               	/* frame size = 0 */
  76               	/* stack size = 0 */
  77               	.L__stack_usage = 0
  56:matrix.c      **** }
  78               		.loc 1 56 0
  79 0000 80E1      		ldi r24,lo8(16)
  80 0002 0895      		ret
  81               		.cfi_endproc
  82               	.LFE7:
  84               		.section	.text.matrix_init,"ax",@progbits
  85               	.global	matrix_init
  87               	matrix_init:
  88               	.LFB8:
  59:matrix.c      **** {
  89               		.loc 1 59 0
  90               		.cfi_startproc
  91               	/* prologue: function */
  92               	/* frame size = 0 */
  93               	/* stack size = 0 */
  94               	.L__stack_usage = 0
  61:matrix.c      ****     MCUCR |= (1<<JTD);
  95               		.loc 1 61 0
  96 0000 85B7      		in r24,0x35
  97 0002 8068      		ori r24,lo8(-128)
  98 0004 85BF      		out 0x35,r24
  62:matrix.c      ****     MCUCR |= (1<<JTD);
  99               		.loc 1 62 0
 100 0006 85B7      		in r24,0x35
 101 0008 8068      		ori r24,lo8(-128)
 102 000a 85BF      		out 0x35,r24
  65:matrix.c      ****     unselect_rows();
 103               		.loc 1 65 0
 104 000c 0E94 0000 		call unselect_rows
 105               	.LVL0:
 106               	.LBB12:
 107               	.LBB13:
 149:matrix.c      ****     DDRA  &= ~(1<<4 | 1<<5 | 1<<6 | 1<<7);
 108               		.loc 1 149 0
 109 0010 81B1      		in r24,0x1
 110 0012 8F70      		andi r24,lo8(15)
 111 0014 81B9      		out 0x1,r24
 150:matrix.c      ****     PORTA |=  (1<<4 | 1<<5 | 1<<6 | 1<<7);
 112               		.loc 1 150 0
 113 0016 82B1      		in r24,0x2
 114 0018 806F      		ori r24,lo8(-16)
 115 001a 82B9      		out 0x2,r24
 151:matrix.c      ****     DDRC  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 116               		.loc 1 151 0
 117 001c 87B1      		in r24,0x7
 118 001e 17B8      		out 0x7,__zero_reg__
 152:matrix.c      ****     PORTC |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 119               		.loc 1 152 0
 120 0020 88B1      		in r24,0x8
 121 0022 8FEF      		ldi r24,lo8(-1)
 122 0024 88B9      		out 0x8,r24
 153:matrix.c      ****     DDRE  &= ~(1<<1 | 1<<0);
 123               		.loc 1 153 0
 124 0026 8DB1      		in r24,0xd
 125 0028 8C7F      		andi r24,lo8(-4)
 126 002a 8DB9      		out 0xd,r24
 154:matrix.c      ****     PORTE |=  (1<<1 | 1<<0);
 127               		.loc 1 154 0
 128 002c 8EB1      		in r24,0xe
 129 002e 8360      		ori r24,lo8(3)
 130 0030 8EB9      		out 0xe,r24
 155:matrix.c      ****     DDRD  &= ~(1<<7 | 1<<5);
 131               		.loc 1 155 0
 132 0032 8AB1      		in r24,0xa
 133 0034 8F75      		andi r24,lo8(95)
 134 0036 8AB9      		out 0xa,r24
 156:matrix.c      ****     PORTD |=  (1<<7 | 1<<5);  
 135               		.loc 1 156 0
 136 0038 8BB1      		in r24,0xb
 137 003a 806A      		ori r24,lo8(-96)
 138 003c 8BB9      		out 0xb,r24
 139               	.LVL1:
 140 003e E0E0      		ldi r30,lo8(matrix)
 141 0040 F0E0      		ldi r31,hi8(matrix)
 142 0042 A0E0      		ldi r26,lo8(matrix_debouncing)
 143 0044 B0E0      		ldi r27,hi8(matrix_debouncing)
 144               	.LVL2:
 145               	.L5:
 146               	.LBE13:
 147               	.LBE12:
 148               	.LBB14:
  70:matrix.c      ****         matrix[i] = 0;
 149               		.loc 1 70 0 discriminator 2
 150 0046 1192      		st Z+,__zero_reg__
 151 0048 1192      		st Z+,__zero_reg__
  71:matrix.c      ****         matrix_debouncing[i] = 0;
 152               		.loc 1 71 0 discriminator 2
 153 004a 1D92      		st X+,__zero_reg__
 154 004c 1D92      		st X+,__zero_reg__
  69:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
 155               		.loc 1 69 0 discriminator 2
 156 004e 80E0      		ldi r24,hi8(matrix+16)
 157 0050 E030      		cpi r30,lo8(matrix+16)
 158 0052 F807      		cpc r31,r24
 159 0054 01F4      		brne .L5
 160               	/* epilogue start */
 161               	.LBE14:
  73:matrix.c      **** }
 162               		.loc 1 73 0
 163 0056 0895      		ret
 164               		.cfi_endproc
 165               	.LFE8:
 167               		.section	.text.matrix_scan,"ax",@progbits
 168               	.global	matrix_scan
 170               	matrix_scan:
 171               	.LFB9:
  76:matrix.c      **** {
 172               		.loc 1 76 0
 173               		.cfi_startproc
 174 0000 AF92      		push r10
 175               	.LCFI0:
 176               		.cfi_def_cfa_offset 3
 177               		.cfi_offset 10, -2
 178 0002 BF92      		push r11
 179               	.LCFI1:
 180               		.cfi_def_cfa_offset 4
 181               		.cfi_offset 11, -3
 182 0004 CF92      		push r12
 183               	.LCFI2:
 184               		.cfi_def_cfa_offset 5
 185               		.cfi_offset 12, -4
 186 0006 DF92      		push r13
 187               	.LCFI3:
 188               		.cfi_def_cfa_offset 6
 189               		.cfi_offset 13, -5
 190 0008 EF92      		push r14
 191               	.LCFI4:
 192               		.cfi_def_cfa_offset 7
 193               		.cfi_offset 14, -6
 194 000a FF92      		push r15
 195               	.LCFI5:
 196               		.cfi_def_cfa_offset 8
 197               		.cfi_offset 15, -7
 198 000c 1F93      		push r17
 199               	.LCFI6:
 200               		.cfi_def_cfa_offset 9
 201               		.cfi_offset 17, -8
 202 000e CF93      		push r28
 203               	.LCFI7:
 204               		.cfi_def_cfa_offset 10
 205               		.cfi_offset 28, -9
 206 0010 DF93      		push r29
 207               	.LCFI8:
 208               		.cfi_def_cfa_offset 11
 209               		.cfi_offset 29, -10
 210               	/* prologue: function */
 211               	/* frame size = 0 */
 212               	/* stack size = 9 */
 213               	.L__stack_usage = 9
 214               	.LVL3:
 215 0012 A0E0      		ldi r26,lo8(matrix_debouncing)
 216 0014 CA2E      		mov r12,r26
 217 0016 A0E0      		ldi r26,hi8(matrix_debouncing)
 218 0018 DA2E      		mov r13,r26
  76:matrix.c      **** {
 219               		.loc 1 76 0
 220 001a 7601      		movw r14,r12
  77:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 221               		.loc 1 77 0
 222 001c C0E0      		ldi r28,0
 223               	.LBB26:
 224               	.LBB27:
 225               	.LBB28:
 226               	.LBB29:
 161:matrix.c      ****     return (PINA&(1<<4) ? 0 : (1<<0)) |
 227               		.loc 1 161 0
 228 001e D1E0      		ldi r29,lo8(1)
 229               	.LBE29:
 230               	.LBE28:
  86:matrix.c      ****             debouncing = DEBOUNCE;
 231               		.loc 1 86 0
 232 0020 15E0      		ldi r17,lo8(5)
 233               	.LVL4:
 234               	.L34:
 235               	.LBB31:
 236               	.LBB32:
 193:matrix.c      **** }
 194:matrix.c      **** 
 195:matrix.c      **** static void select_row(uint8_t row)
 196:matrix.c      **** {
 197:matrix.c      ****     // Output low(DDR:1, PORT:0) to select
 198:matrix.c      ****     switch (row) {
 237               		.loc 1 198 0
 238 0022 C430      		cpi r28,lo8(4)
 239 0024 01F0      		breq .L12
 240 0026 00F4      		brsh .L16
 241 0028 C230      		cpi r28,lo8(2)
 242 002a 01F0      		breq .L10
 243 002c 00F4      		brsh .L11
 244 002e C130      		cpi r28,lo8(1)
 245 0030 01F4      		brne .L8
 246 0032 00C0      		rjmp .L9
 247               	.L16:
 248 0034 C630      		cpi r28,lo8(6)
 249 0036 01F0      		breq .L14
 250 0038 00F0      		brlo .L13
 251 003a C730      		cpi r28,lo8(7)
 252 003c 01F4      		brne .L8
 199:matrix.c      ****         case 7:
 200:matrix.c      ****             DDRD  |= (1<<4);
 253               		.loc 1 200 0
 254 003e 549A      		sbi 0xa,4
 201:matrix.c      ****             PORTD &= ~(1<<4);
 255               		.loc 1 201 0
 256 0040 5C98      		cbi 0xb,4
 257 0042 00C0      		rjmp .L17
 258               	.L14:
 202:matrix.c      ****             break;
 203:matrix.c      ****         case 6:
 204:matrix.c      ****             DDRD  |= (1<<1);
 259               		.loc 1 204 0
 260 0044 519A      		sbi 0xa,1
 205:matrix.c      ****             PORTD &= ~(1<<1);
 261               		.loc 1 205 0
 262 0046 5998      		cbi 0xb,1
 263 0048 00C0      		rjmp .L17
 264               	.L13:
 206:matrix.c      ****             break;
 207:matrix.c      ****         case 5:
 208:matrix.c      ****             DDRD  |= (1<<0);
 265               		.loc 1 208 0
 266 004a 509A      		sbi 0xa,0
 209:matrix.c      ****             PORTD &= ~(1<<0);
 267               		.loc 1 209 0
 268 004c 5898      		cbi 0xb,0
 269 004e 00C0      		rjmp .L17
 270               	.L12:
 210:matrix.c      ****             break;
 211:matrix.c      ****         case 4:
 212:matrix.c      ****             DDRE  |= (1<<5);
 271               		.loc 1 212 0
 272 0050 6D9A      		sbi 0xd,5
 213:matrix.c      ****             PORTE &= ~(1<<5);
 273               		.loc 1 213 0
 274 0052 7598      		cbi 0xe,5
 275 0054 00C0      		rjmp .L17
 276               	.L11:
 214:matrix.c      ****             break;
 215:matrix.c      ****         case 3:
 216:matrix.c      ****             DDRE  |= (1<<4);
 277               		.loc 1 216 0
 278 0056 6C9A      		sbi 0xd,4
 217:matrix.c      ****             PORTE &= ~(1<<4);
 279               		.loc 1 217 0
 280 0058 7498      		cbi 0xe,4
 281 005a 00C0      		rjmp .L17
 282               	.L10:
 218:matrix.c      ****             break;
 219:matrix.c      ****         case 2:
 220:matrix.c      ****             DDRB  |= (1<<7);
 283               		.loc 1 220 0
 284 005c 279A      		sbi 0x4,7
 221:matrix.c      ****             PORTB &= ~(1<<7);
 285               		.loc 1 221 0
 286 005e 2F98      		cbi 0x5,7
 287 0060 00C0      		rjmp .L17
 288               	.L9:
 222:matrix.c      ****             break;
 223:matrix.c      ****         case 1:
 224:matrix.c      ****             DDRB  |= (1<<6);
 289               		.loc 1 224 0
 290 0062 269A      		sbi 0x4,6
 225:matrix.c      ****             PORTB &= ~(1<<6);
 291               		.loc 1 225 0
 292 0064 2E98      		cbi 0x5,6
 293 0066 00C0      		rjmp .L17
 294               	.L8:
 226:matrix.c      ****             break;
 227:matrix.c      ****         case 0:
 228:matrix.c      ****             DDRB  |= (1<<5);
 295               		.loc 1 228 0
 296 0068 259A      		sbi 0x4,5
 229:matrix.c      ****             PORTB &= ~(1<<5);
 297               		.loc 1 229 0
 298 006a 2D98      		cbi 0x5,5
 299               	.L17:
 300               	.LVL5:
 301               	.LBE32:
 302               	.LBE31:
 303               	.LBB33:
 304               	.LBB34:
 305               		.file 2 "/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h"
   1:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
   6:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
   9:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  12:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  17:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  21:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  33:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  35:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  38:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  41:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  42:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  46:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \code
  49:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  54:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     used.
  58:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  59:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  68:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  77:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  81:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** */
  82:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  83:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  87:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  88:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  93:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  94:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
  97:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
  98:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
 103:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 104:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /**
 105:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 107:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 109:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 112:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 114:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 120:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 125:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 129:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 132:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 140:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****  */
 141:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** void
 142:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** {
 144:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 153:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 156:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 159:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 164:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 166:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #else
 167:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	{
 172:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		{
 176:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		}
 180:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	}
 182:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	else
 183:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #endif
 186:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** }
 187:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 188:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** /**
 189:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 191:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 193:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 196:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 198:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 202:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   
 207:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 211:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****  
 214:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 222:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****  */
 223:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** void
 224:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** {
 226:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 235:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 238:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 241:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 
 246:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 306               		.loc 2 246 0
 307 006c 80EA      		ldi r24,lo8(-96)
 308 006e 8A95      		1: dec r24
 309 0070 01F4      		brne 1b
 310               	.LBE34:
 311               	.LBE33:
 312               	.LBB35:
 313               	.LBB30:
 161:matrix.c      ****     return (PINA&(1<<4) ? 0 : (1<<0)) |
 314               		.loc 1 161 0
 315 0072 80B1      		in r24,0
 316 0074 8295      		swap r24
 317 0076 8F70      		andi r24,lo8(15)
 318 0078 8D27      		eor r24,r29
 319 007a 80FB      		bst r24,0
 320 007c AA24      		clr r10
 321 007e A0F8      		bld r10,0
 322 0080 B12C      		mov r11,__zero_reg__
 162:matrix.c      ****            (PINA&(1<<5) ? 0 : (1<<1)) |
 323               		.loc 1 162 0
 324 0082 059B      		sbis 0,5
 325 0084 00C0      		rjmp .L40
 326 0086 20E0      		ldi r18,0
 327 0088 30E0      		ldi r19,0
 328 008a 00C0      		rjmp .L18
 329               	.L40:
 330 008c 22E0      		ldi r18,lo8(2)
 331 008e 30E0      		ldi r19,0
 332               	.L18:
 161:matrix.c      ****     return (PINA&(1<<4) ? 0 : (1<<0)) |
 333               		.loc 1 161 0
 334 0090 2A29      		or r18,r10
 335 0092 3B29      		or r19,r11
 163:matrix.c      ****            (PINA&(1<<6) ? 0 : (1<<2)) |
 336               		.loc 1 163 0
 337 0094 069B      		sbis 0,6
 338 0096 00C0      		rjmp .L41
 339 0098 80E0      		ldi r24,0
 340 009a 90E0      		ldi r25,0
 341 009c 00C0      		rjmp .L19
 342               	.L41:
 343 009e 84E0      		ldi r24,lo8(4)
 344 00a0 90E0      		ldi r25,0
 345               	.L19:
 162:matrix.c      ****            (PINA&(1<<5) ? 0 : (1<<1)) |
 346               		.loc 1 162 0
 347 00a2 282B      		or r18,r24
 348 00a4 392B      		or r19,r25
 164:matrix.c      ****            (PINA&(1<<7) ? 0 : (1<<3)) |
 349               		.loc 1 164 0
 350 00a6 80B1      		in r24,0
 351 00a8 9927      		clr r25
 352 00aa 87FD      		sbrc r24,7
 353 00ac 9095      		com r25
 354 00ae 8095      		com r24
 355 00b0 9095      		com r25
 356 00b2 8827      		clr r24
 357 00b4 990F      		lsl r25
 358 00b6 881F      		rol r24
 359 00b8 9927      		clr r25
 360 00ba 73E0      		ldi r23,3
 361               		1:
 362 00bc 880F      		lsl r24
 363 00be 991F      		rol r25
 364 00c0 7A95      		dec r23
 365 00c2 01F4      		brne 1b
 163:matrix.c      ****            (PINA&(1<<6) ? 0 : (1<<2)) |
 366               		.loc 1 163 0
 367 00c4 282B      		or r18,r24
 368 00c6 392B      		or r19,r25
 165:matrix.c      ****            (PINC&(1<<7) ? 0 : (1<<4)) |
 369               		.loc 1 165 0
 370 00c8 86B1      		in r24,0x6
 371 00ca 9927      		clr r25
 372 00cc 87FD      		sbrc r24,7
 373 00ce 9095      		com r25
 374 00d0 8095      		com r24
 375 00d2 9095      		com r25
 376 00d4 8827      		clr r24
 377 00d6 990F      		lsl r25
 378 00d8 881F      		rol r24
 379 00da 9927      		clr r25
 380 00dc F4E0      		ldi r31,4
 381               		1:
 382 00de 880F      		lsl r24
 383 00e0 991F      		rol r25
 384 00e2 FA95      		dec r31
 385 00e4 01F4      		brne 1b
 164:matrix.c      ****            (PINA&(1<<7) ? 0 : (1<<3)) |
 386               		.loc 1 164 0
 387 00e6 282B      		or r18,r24
 388 00e8 392B      		or r19,r25
 166:matrix.c      ****            (PINC&(1<<6) ? 0 : (1<<5)) |
 389               		.loc 1 166 0
 390 00ea 369B      		sbis 0x6,6
 391 00ec 00C0      		rjmp .L44
 392 00ee 80E0      		ldi r24,0
 393 00f0 90E0      		ldi r25,0
 394 00f2 00C0      		rjmp .L22
 395               	.L44:
 396 00f4 80E2      		ldi r24,lo8(32)
 397 00f6 90E0      		ldi r25,0
 398               	.L22:
 165:matrix.c      ****            (PINC&(1<<7) ? 0 : (1<<4)) |
 399               		.loc 1 165 0
 400 00f8 282B      		or r18,r24
 401 00fa 392B      		or r19,r25
 167:matrix.c      ****            (PINC&(1<<5) ? 0 : (1<<6)) |
 402               		.loc 1 167 0
 403 00fc 359B      		sbis 0x6,5
 404 00fe 00C0      		rjmp .L45
 405 0100 80E0      		ldi r24,0
 406 0102 90E0      		ldi r25,0
 407 0104 00C0      		rjmp .L23
 408               	.L45:
 409 0106 80E4      		ldi r24,lo8(64)
 410 0108 90E0      		ldi r25,0
 411               	.L23:
 166:matrix.c      ****            (PINC&(1<<6) ? 0 : (1<<5)) |
 412               		.loc 1 166 0
 413 010a 282B      		or r18,r24
 414 010c 392B      		or r19,r25
 168:matrix.c      ****            (PINC&(1<<4) ? 0 : (1<<7)) |
 415               		.loc 1 168 0
 416 010e 349B      		sbis 0x6,4
 417 0110 00C0      		rjmp .L46
 418 0112 60E0      		ldi r22,0
 419 0114 70E0      		ldi r23,0
 420 0116 00C0      		rjmp .L24
 421               	.L46:
 422 0118 60E8      		ldi r22,lo8(-128)
 423 011a 70E0      		ldi r23,0
 424               	.L24:
 167:matrix.c      ****            (PINC&(1<<5) ? 0 : (1<<6)) |
 425               		.loc 1 167 0
 426 011c 262B      		or r18,r22
 427 011e 372B      		or r19,r23
 169:matrix.c      ****            (PINC&(1<<3) ? 0 : (1<<8)) |
 428               		.loc 1 169 0
 429 0120 339B      		sbis 0x6,3
 430 0122 00C0      		rjmp .L47
 431 0124 40E0      		ldi r20,0
 432 0126 50E0      		ldi r21,0
 433 0128 00C0      		rjmp .L25
 434               	.L47:
 435 012a 40E0      		ldi r20,0
 436 012c 51E0      		ldi r21,lo8(1)
 437               	.L25:
 168:matrix.c      ****            (PINC&(1<<4) ? 0 : (1<<7)) |
 438               		.loc 1 168 0
 439 012e 242B      		or r18,r20
 440 0130 352B      		or r19,r21
 170:matrix.c      ****            (PINC&(1<<2) ? 0 : (1<<9)) |
 441               		.loc 1 170 0
 442 0132 329B      		sbis 0x6,2
 443 0134 00C0      		rjmp .L48
 444 0136 80E0      		ldi r24,0
 445 0138 90E0      		ldi r25,0
 446 013a 00C0      		rjmp .L26
 447               	.L48:
 448 013c 80E0      		ldi r24,0
 449 013e 92E0      		ldi r25,lo8(2)
 450               	.L26:
 169:matrix.c      ****            (PINC&(1<<3) ? 0 : (1<<8)) |
 451               		.loc 1 169 0
 452 0140 282B      		or r18,r24
 453 0142 392B      		or r19,r25
 171:matrix.c      ****            (PINC&(1<<1) ? 0 : (1<<10)) |
 454               		.loc 1 171 0
 455 0144 319B      		sbis 0x6,1
 456 0146 00C0      		rjmp .L49
 457 0148 60E0      		ldi r22,0
 458 014a 70E0      		ldi r23,0
 459 014c 00C0      		rjmp .L27
 460               	.L49:
 461 014e 60E0      		ldi r22,0
 462 0150 74E0      		ldi r23,lo8(4)
 463               	.L27:
 170:matrix.c      ****            (PINC&(1<<2) ? 0 : (1<<9)) |
 464               		.loc 1 170 0
 465 0152 262B      		or r18,r22
 466 0154 372B      		or r19,r23
 172:matrix.c      ****            (PINC&(1<<0) ? 0 : (1<<11)) |
 467               		.loc 1 172 0
 468 0156 309B      		sbis 0x6,0
 469 0158 00C0      		rjmp .L50
 470 015a 40E0      		ldi r20,0
 471 015c 50E0      		ldi r21,0
 472 015e 00C0      		rjmp .L28
 473               	.L50:
 474 0160 40E0      		ldi r20,0
 475 0162 58E0      		ldi r21,lo8(8)
 476               	.L28:
 171:matrix.c      ****            (PINC&(1<<1) ? 0 : (1<<10)) |
 477               		.loc 1 171 0
 478 0164 242B      		or r18,r20
 479 0166 352B      		or r19,r21
 173:matrix.c      ****            (PINE&(1<<1) ? 0 : (1<<12)) |
 480               		.loc 1 173 0
 481 0168 619B      		sbis 0xc,1
 482 016a 00C0      		rjmp .L51
 483 016c 80E0      		ldi r24,0
 484 016e 90E0      		ldi r25,0
 485 0170 00C0      		rjmp .L29
 486               	.L51:
 487 0172 80E0      		ldi r24,0
 488 0174 90E1      		ldi r25,lo8(16)
 489               	.L29:
 172:matrix.c      ****            (PINC&(1<<0) ? 0 : (1<<11)) |
 490               		.loc 1 172 0
 491 0176 282B      		or r18,r24
 492 0178 392B      		or r19,r25
 174:matrix.c      ****            (PINE&(1<<0) ? 0 : (1<<13)) |
 493               		.loc 1 174 0
 494 017a 609B      		sbis 0xc,0
 495 017c 00C0      		rjmp .L52
 496 017e 80E0      		ldi r24,0
 497 0180 90E0      		ldi r25,0
 498 0182 00C0      		rjmp .L30
 499               	.L52:
 500 0184 80E0      		ldi r24,0
 501 0186 90E2      		ldi r25,lo8(32)
 502               	.L30:
 173:matrix.c      ****            (PINE&(1<<1) ? 0 : (1<<12)) |
 503               		.loc 1 173 0
 504 0188 282B      		or r18,r24
 505 018a 392B      		or r19,r25
 175:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<<14)) |
 506               		.loc 1 175 0
 507 018c 89B1      		in r24,0x9
 508 018e 9927      		clr r25
 509 0190 87FD      		sbrc r24,7
 510 0192 9095      		com r25
 511 0194 8095      		com r24
 512 0196 9095      		com r25
 513 0198 8827      		clr r24
 514 019a 990F      		lsl r25
 515 019c 881F      		rol r24
 516 019e 9927      		clr r25
 517 01a0 90E4      		ldi r25,0x40
 518 01a2 899F      		mul r24,r25
 519 01a4 902D      		mov r25,r0
 520 01a6 8827      		clr r24
 521 01a8 1124      		clr __zero_reg__
 174:matrix.c      ****            (PINE&(1<<0) ? 0 : (1<<13)) |
 522               		.loc 1 174 0
 523 01aa 282B      		or r18,r24
 524 01ac 392B      		or r19,r25
 176:matrix.c      ****            (PIND&(1<<5) ? 0 : (1<<15));
 525               		.loc 1 176 0
 526 01ae 4D9B      		sbis 0x9,5
 527 01b0 00C0      		rjmp .L54
 528 01b2 80E0      		ldi r24,0
 529 01b4 90E0      		ldi r25,0
 530 01b6 00C0      		rjmp .L32
 531               	.L54:
 532 01b8 80E0      		ldi r24,0
 533 01ba 90E8      		ldi r25,lo8(-128)
 534               	.L32:
 175:matrix.c      ****            (PIND&(1<<7) ? 0 : (1<<14)) |
 535               		.loc 1 175 0
 536 01bc 282B      		or r18,r24
 537 01be 392B      		or r19,r25
 538               	.LBE30:
 539               	.LBE35:
  81:matrix.c      ****         if (matrix_debouncing[i] != cols) {
 540               		.loc 1 81 0
 541 01c0 D701      		movw r26,r14
 542 01c2 8D91      		ld r24,X+
 543 01c4 9C91      		ld r25,X
 544 01c6 1197      		sbiw r26,1
 545 01c8 8217      		cp r24,r18
 546 01ca 9307      		cpc r25,r19
 547 01cc 01F0      		breq .L33
  82:matrix.c      ****             matrix_debouncing[i] = cols;
 548               		.loc 1 82 0
 549 01ce 2D93      		st X+,r18
 550 01d0 3C93      		st X,r19
  86:matrix.c      ****             debouncing = DEBOUNCE;
 551               		.loc 1 86 0
 552 01d2 1093 0000 		sts debouncing,r17
 553               	.L33:
  88:matrix.c      ****         unselect_rows();
 554               		.loc 1 88 0
 555 01d6 0E94 0000 		call unselect_rows
 556               	.LVL6:
 557               	.LBE27:
  77:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 558               		.loc 1 77 0
 559 01da CF5F      		subi r28,lo8(-(1))
 560               	.LVL7:
 561 01dc B2E0      		ldi r27,2
 562 01de EB0E      		add r14,r27
 563 01e0 F11C      		adc r15,__zero_reg__
 564 01e2 C830      		cpi r28,lo8(8)
 565 01e4 01F0      		breq .+2
 566 01e6 00C0      		rjmp .L34
 567               	.LBE26:
  91:matrix.c      ****     if (debouncing) {
 568               		.loc 1 91 0
 569 01e8 8091 0000 		lds r24,debouncing
 570 01ec 8823      		tst r24
 571 01ee 01F0      		breq .L36
  92:matrix.c      ****         if (--debouncing) {
 572               		.loc 1 92 0
 573 01f0 8150      		subi r24,lo8(-(-1))
 574 01f2 8093 0000 		sts debouncing,r24
 575 01f6 8823      		tst r24
 576 01f8 01F0      		breq .L37
 577               	.LVL8:
 578               	.LBB36:
 579               	.LBB37:
 164:/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 580               		.loc 2 164 0
 581 01fa EFE9      		ldi r30,lo8(3999)
 582 01fc FFE0      		ldi r31,hi8(3999)
 583 01fe 3197      		1: sbiw r30,1
 584 0200 01F4      		brne 1b
 585 0202 00C0      		rjmp .
 586 0204 0000      		nop
 587 0206 00C0      		rjmp .L36
 588               	.LVL9:
 589               	.L37:
 590 0208 E0E0      		ldi r30,lo8(matrix)
 591 020a F0E0      		ldi r31,hi8(matrix)
 592               	.L38:
 593               	.LBE37:
 594               	.LBE36:
 595               	.LBB38:
  96:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 596               		.loc 1 96 0 discriminator 2
 597 020c D601      		movw r26,r12
 598 020e 8D91      		ld r24,X+
 599 0210 9D91      		ld r25,X+
 600 0212 6D01      		movw r12,r26
 601 0214 8193      		st Z+,r24
 602 0216 9193      		st Z+,r25
 603               	.LVL10:
  95:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 604               		.loc 1 95 0 discriminator 2
 605 0218 B0E0      		ldi r27,lo8(matrix_debouncing+16)
 606 021a CB16      		cp r12,r27
 607 021c B0E0      		ldi r27,hi8(matrix_debouncing+16)
 608 021e DB06      		cpc r13,r27
 609 0220 01F4      		brne .L38
 610               	.L36:
 611               	.LBE38:
 102:matrix.c      **** }
 612               		.loc 1 102 0
 613 0222 81E0      		ldi r24,lo8(1)
 614               	/* epilogue start */
 615 0224 DF91      		pop r29
 616 0226 CF91      		pop r28
 617               	.LVL11:
 618 0228 1F91      		pop r17
 619 022a FF90      		pop r15
 620 022c EF90      		pop r14
 621 022e DF90      		pop r13
 622 0230 CF90      		pop r12
 623 0232 BF90      		pop r11
 624 0234 AF90      		pop r10
 625 0236 0895      		ret
 626               		.cfi_endproc
 627               	.LFE9:
 629               		.section	.text.matrix_is_modified,"ax",@progbits
 630               	.global	matrix_is_modified
 632               	matrix_is_modified:
 633               	.LFB10:
 105:matrix.c      **** {
 634               		.loc 1 105 0
 635               		.cfi_startproc
 636               	/* prologue: function */
 637               	/* frame size = 0 */
 638               	/* stack size = 0 */
 639               	.L__stack_usage = 0
 106:matrix.c      ****     if (debouncing) return false;
 640               		.loc 1 106 0
 641 0000 81E0      		ldi r24,lo8(1)
 642 0002 9091 0000 		lds r25,debouncing
 643 0006 9111      		cpse r25,__zero_reg__
 644 0008 80E0      		ldi r24,0
 645               	.L58:
 108:matrix.c      **** }
 646               		.loc 1 108 0
 647 000a 0895      		ret
 648               		.cfi_endproc
 649               	.LFE10:
 651               		.section	.text.matrix_is_on,"ax",@progbits
 652               	.global	matrix_is_on
 654               	matrix_is_on:
 655               	.LFB11:
 112:matrix.c      **** {
 656               		.loc 1 112 0
 657               		.cfi_startproc
 658               	.LVL12:
 659               	/* prologue: function */
 660               	/* frame size = 0 */
 661               	/* stack size = 0 */
 662               	.L__stack_usage = 0
 113:matrix.c      ****     return (matrix[row] & ((matrix_row_t)1<<col));
 663               		.loc 1 113 0
 664 0000 21E0      		ldi r18,lo8(1)
 665 0002 30E0      		ldi r19,0
 666 0004 00C0      		rjmp 2f
 667               		1:
 668 0006 220F      		lsl r18
 669 0008 331F      		rol r19
 670               		2:
 671 000a 6A95      		dec r22
 672 000c 02F4      		brpl 1b
 673 000e E82F      		mov r30,r24
 674 0010 F0E0      		ldi r31,0
 675 0012 EE0F      		lsl r30
 676 0014 FF1F      		rol r31
 677 0016 E050      		subi r30,lo8(-(matrix))
 678 0018 F040      		sbci r31,hi8(-(matrix))
 679 001a 8081      		ld r24,Z
 680 001c 9181      		ldd r25,Z+1
 681               	.LVL13:
 682 001e 2823      		and r18,r24
 683 0020 3923      		and r19,r25
 684 0022 81E0      		ldi r24,lo8(1)
 685 0024 232B      		or r18,r19
 686 0026 01F4      		brne .L63
 687 0028 80E0      		ldi r24,0
 688               	.L63:
 114:matrix.c      **** }
 689               		.loc 1 114 0
 690 002a 0895      		ret
 691               		.cfi_endproc
 692               	.LFE11:
 694               		.section	.text.matrix_get_row,"ax",@progbits
 695               	.global	matrix_get_row
 697               	matrix_get_row:
 698               	.LFB12:
 118:matrix.c      **** {
 699               		.loc 1 118 0
 700               		.cfi_startproc
 701               	.LVL14:
 702               	/* prologue: function */
 703               	/* frame size = 0 */
 704               	/* stack size = 0 */
 705               	.L__stack_usage = 0
 119:matrix.c      ****     return matrix[row];
 706               		.loc 1 119 0
 707 0000 E82F      		mov r30,r24
 708 0002 F0E0      		ldi r31,0
 709 0004 EE0F      		lsl r30
 710 0006 FF1F      		rol r31
 711               	.LVL15:
 712 0008 E050      		subi r30,lo8(-(matrix))
 713 000a F040      		sbci r31,hi8(-(matrix))
 120:matrix.c      **** }
 714               		.loc 1 120 0
 715 000c 8081      		ld r24,Z
 716 000e 9181      		ldd r25,Z+1
 717 0010 0895      		ret
 718               		.cfi_endproc
 719               	.LFE12:
 721               		.section	.text.matrix_print,"ax",@progbits
 722               	.global	matrix_print
 724               	matrix_print:
 725               	.LFB13:
 123:matrix.c      **** {
 726               		.loc 1 123 0
 727               		.cfi_startproc
 728               	/* prologue: function */
 729               	/* frame size = 0 */
 730               	/* stack size = 0 */
 731               	.L__stack_usage = 0
 732               	.LVL16:
 733 0000 0895      		ret
 734               		.cfi_endproc
 735               	.LFE13:
 737               		.section	.text.matrix_key_count,"ax",@progbits
 738               	.global	matrix_key_count
 740               	matrix_key_count:
 741               	.LFB14:
 133:matrix.c      **** {
 742               		.loc 1 133 0
 743               		.cfi_startproc
 133:matrix.c      **** {
 744               		.loc 1 133 0
 745 0000 EF92      		push r14
 746               	.LCFI9:
 747               		.cfi_def_cfa_offset 3
 748               		.cfi_offset 14, -2
 749 0002 FF92      		push r15
 750               	.LCFI10:
 751               		.cfi_def_cfa_offset 4
 752               		.cfi_offset 15, -3
 753 0004 CF93      		push r28
 754               	.LCFI11:
 755               		.cfi_def_cfa_offset 5
 756               		.cfi_offset 28, -4
 757               	/* prologue: function */
 758               	/* frame size = 0 */
 759               	/* stack size = 3 */
 760               	.L__stack_usage = 3
 761               	.LVL17:
 762 0006 90E0      		ldi r25,lo8(matrix)
 763 0008 E92E      		mov r14,r25
 764 000a 90E0      		ldi r25,hi8(matrix)
 765 000c F92E      		mov r15,r25
 134:matrix.c      ****     uint8_t count = 0;
 766               		.loc 1 134 0
 767 000e C0E0      		ldi r28,0
 768               	.LVL18:
 769               	.L67:
 770               	.LBB39:
 136:matrix.c      ****         count += bitpop16(matrix[i]);
 771               		.loc 1 136 0 discriminator 2
 772 0010 F701      		movw r30,r14
 773 0012 8191      		ld r24,Z+
 774 0014 9191      		ld r25,Z+
 775 0016 7F01      		movw r14,r30
 776 0018 0E94 0000 		call bitpop16
 777               	.LVL19:
 778 001c C80F      		add r28,r24
 779               	.LVL20:
 135:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 780               		.loc 1 135 0 discriminator 2
 781 001e F0E0      		ldi r31,lo8(matrix+16)
 782 0020 EF16      		cp r14,r31
 783 0022 F0E0      		ldi r31,hi8(matrix+16)
 784 0024 FF06      		cpc r15,r31
 785 0026 01F4      		brne .L67
 786               	.LBE39:
 139:matrix.c      **** }
 787               		.loc 1 139 0
 788 0028 8C2F      		mov r24,r28
 789               	/* epilogue start */
 790 002a CF91      		pop r28
 791               	.LVL21:
 792 002c FF90      		pop r15
 793 002e EF90      		pop r14
 794 0030 0895      		ret
 795               		.cfi_endproc
 796               	.LFE14:
 798               		.section	.bss.matrix,"aw",@nobits
 801               	matrix:
 802 0000 0000 0000 		.zero	16
 802      0000 0000 
 802      0000 0000 
 802      0000 0000 
 803               		.section	.bss.matrix_debouncing,"aw",@nobits
 806               	matrix_debouncing:
 807 0000 0000 0000 		.zero	16
 807      0000 0000 
 807      0000 0000 
 807      0000 0000 
 808               		.section	.data.debouncing,"aw",@progbits
 811               	debouncing:
 812 0000 05        		.byte	5
 813               		.text
 814               	.Letext0:
 815               		.file 3 "/usr/lib64/gcc/avr/4.7.1/../../../../avr/include/stdint.h"
 816               		.file 4 "../../../../tmk_core/common/matrix.h"
 817               		.file 5 "../../../../tmk_core/common/util.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/cc9gYJMy.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc9gYJMy.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc9gYJMy.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc9gYJMy.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/cc9gYJMy.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc9gYJMy.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc9gYJMy.s:13     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/cc9gYJMy.s:53     .text.matrix_rows:0000000000000000 matrix_rows
     /tmp/cc9gYJMy.s:70     .text.matrix_cols:0000000000000000 matrix_cols
     /tmp/cc9gYJMy.s:87     .text.matrix_init:0000000000000000 matrix_init
     /tmp/cc9gYJMy.s:801    .bss.matrix:0000000000000000 matrix
     /tmp/cc9gYJMy.s:806    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/cc9gYJMy.s:170    .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/cc9gYJMy.s:811    .data.debouncing:0000000000000000 debouncing
     /tmp/cc9gYJMy.s:632    .text.matrix_is_modified:0000000000000000 matrix_is_modified
     /tmp/cc9gYJMy.s:654    .text.matrix_is_on:0000000000000000 matrix_is_on
     /tmp/cc9gYJMy.s:697    .text.matrix_get_row:0000000000000000 matrix_get_row
     /tmp/cc9gYJMy.s:724    .text.matrix_print:0000000000000000 matrix_print
     /tmp/cc9gYJMy.s:740    .text.matrix_key_count:0000000000000000 matrix_key_count

UNDEFINED SYMBOLS
bitpop16
__do_copy_data
__do_clear_bss
